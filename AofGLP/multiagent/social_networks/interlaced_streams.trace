=== interlaced_streams.glp ===
Interlaced streams as distributed blocklace.

Blocklace: DAG where each block references multiple predecessors.
Enables concurrent block creation without consensus.

Each process maintains stream of blocks with payloads and references
to most recent blocks observed from others. reader(X) guard identifies
unprocessed blocks by detecting unbound tail variables.

--- Test: Single agent (no other streams) ---
Query: streams(S, []).
Expected: S = stream([block(p1, []), block(p2, []), block(p3, [])])

Trace:
streams(S, []) :- produce_payloads(X1), interlace(X1?, X2, [], [])
produce_payloads(X1) :- true
interlace([p1, p2, p3], X2, [], []) :- collect_tips([], X3, X4), build_and_continue(p1, X3?, X5, [p2, p3], X4?)
collect_tips([], X3, X4) :- true
build_and_continue(p1, [], X5, [p2, p3], []) :- interlace([p2, p3], X6, [], [])
interlace([p2, p3], X6, [], []) :- collect_tips([], X7, X8), build_and_continue(p2, X7?, X9, [p3], X8?)
collect_tips([], X7, X8) :- true
build_and_continue(p2, [], X9, [p3], []) :- interlace([p3], X10, [], [])
interlace([p3], X10, [], []) :- collect_tips([], X11, X12), build_and_continue(p3, X11?, X13, [], X12?)
collect_tips([], X11, X12) :- true
build_and_continue(p3, [], X13, [], []) :- interlace([], X14, [], [])
interlace([], X14, [], []) :- true

Result:
S = stream([block(p1, []), block(p2, []), block(p3, [])])
â†’ succeeds
