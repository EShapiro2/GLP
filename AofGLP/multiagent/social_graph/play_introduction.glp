%% play_introduction.glp - Friend-mediated introduction play
%% Round 1: Alice cold-calls Bob (Bob accepts)
%% Round 2: Alice cold-calls Carol (Carol accepts)
%% Round 3: Alice introduces Bob to Carol (both accept)
%% Result: All three are mutual friends
%%
%% This tests both cold-call and friend introduction protocols

%% === Library predicates ===

merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], Ys?, Ys).
merge(Xs?, [], Xs).

tag_stream(Name, [M|In], [msg(Name?, M?)|Out?]) :-
    ground(Name?) | tag_stream(Name?, In?, Out).
tag_stream(_, [], []).

%% lookup(Key, List, Value) - find value associated with key
lookup(Key, [(K, Value)|_], Value?) :- Key? =?= K? | true.
lookup(Key, [_|Rest], Value?) :-
    otherwise | lookup(Key?, Rest?, Value).

%% lookup_send(Key, Msg, Fs, Fs1) - send message through channel, update list
lookup_send(Key, Msg, Fs, Fs1?) :-
    ground(Key?) |
    lookup_send_step(Key?, Msg?, Fs?, Fs1).

lookup_send_step(Key, Msg, [(K, Out)|Rest], [(K?, Out1?)|Rest?]) :-
    Key? =?= K? |
    Out? = [Msg?|Out1].
lookup_send_step(Key, Msg, [Pair|Rest], [Pair?|Rest1?]) :-
    otherwise |
    lookup_send_step(Key?, Msg?, Rest?, Rest1).

%% === Agent initialization ===

agent(Id, ch(UserIn, UserOut), ch(NetIn, NetOut)) :-
    merge(UserIn?, NetIn?, In),
    build_friends(UserOut?, NetOut?, Fs),
    social_graph(Id?, In?, Fs?).

build_friends(UserOut, NetOut, [(user, UserOut?), (net, NetOut?)]).

%% === User commands and friend introduction receives ===
%% These must come BEFORE cold-call protocol clauses

%% User: introduce P to Q (creates bidirectional channel)
social_graph(Id, [msg(user, Id?, introduce(P, Q))|In], Fs) :-
    ground(Id?), ground(P?), ground(Q?) |
    lookup_send(P?, msg(Id?, P?, intro(Q?, ch(QP?, PQ))), Fs?, Fs1),
    lookup_send(Q?, msg(Id?, Q?, intro(P?, ch(PQ?, QP))), Fs1?, Fs2),
    social_graph(Id?, In?, Fs2?).

%% Receive introduction from friend (2-arg intro, different from cold-call 3-arg)
social_graph(Id, [msg(From, Id?, intro(Other, Ch))|In], Fs) :-
    ground(Id?), ground(From?), ground(Other?) |
    lookup_send(user, msg(agent, user, befriend_intro(From?, Other?, Ch?)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).

%% User accepts introduction
social_graph(Id, [msg(user, Id?, accept_intro(Other, ch(FIn, FOut)))|In], Fs) :-
    ground(Id?), ground(Other?) |
    merge(In?, FIn?, In1),
    add_friend(Other?, FOut?, Fs?, Fs1),
    social_graph(Id?, In1?, Fs1?).

%% User rejects introduction
social_graph(Id, [msg(user, Id?, reject_intro(_, _))|In], Fs) :-
    ground(Id?) |
    social_graph(Id?, In?, Fs?).

%% === Cold-call protocol (GLPSAM) ===

social_graph(Id, [msg(user, Id?, connect(Target))|In], Fs) :-
    ground(Id?), ground(Target?) |
    lookup_send(net, msg(Id?, Target?, intro(Id?, Id?, Resp)), Fs?, Fs1),
    inject_msg(Resp?, Target?, Id?, In?, In1),
    social_graph(Id?, In1?, Fs1?).

social_graph(Id, [msg(From, Id?, intro(From?, From?, Resp))|In], Fs) :-
    ground(Id?), ground(From?) |
    lookup_send(user, msg(agent, user, befriend(From?, Resp?)), Fs?, Fs1),
    social_graph(Id?, In?, Fs1?).

social_graph(Id, [msg(user, Id?, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id?) |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    social_graph(Id?, In1?, Fs1?).

social_graph(Id, [msg(From, Id?, response(Resp))|In], Fs) :-
    ground(Id?) |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    social_graph(Id?, In1?, Fs1?).

inject_msg(Resp, Target, Id, Ys, [msg(Target?, Id?, response(Resp?))|Ys?]) :-
    known(Resp?) | true.
inject_msg(Resp, Target, Id, [Y|Ys], [Y?|Ys1?]) :-
    otherwise | inject_msg(Resp?, Target?, Id?, Ys?, Ys1).

add_friend(Name, Out, Fs, [(Name?, Out?)|Fs?]).

%% === Response handling (GLPSAM) ===

bind_response(yes, From, accept(ch(FOut?, FIn)), Fs, Fs1?, In, In1?) :-
    handle_response(accept(ch(FIn?, FOut)), From?, Fs?, Fs1, In?, In1).
bind_response(no, _, no, Fs, Fs?, In, In?).

%% Note: Private channel messages already have msg(From, To, Content) format
%% so we merge directly without tag_stream (which would double-wrap)
handle_response(accept(ch(FIn, FOut)), From, Fs, [(From?, FOut?)|Fs?], In, In1?) :-
    ground(From?) |
    merge(In?, FIn?, In1).
handle_response(no, _, Fs, Fs?, In, In?).

%% Catch-all for unmatched messages
social_graph(Id, [msg(_, _, _)|In], Fs) :-
    ground(Id?), otherwise |
    social_graph(Id?, In?, Fs?).

%% === Network switch (3-way with swap pattern) ===

%% Alice sends to Bob
network3((alice, ch([msg(alice, bob, X)|AliceIn], AliceOut?)),
         (bob, ch(BobIn, [msg(alice, bob, X?)|BobOut?])),
         (carol, ch(CarolIn, CarolOut?))) :-
    network3((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut)),
             (carol, ch(CarolIn?, CarolOut))).

%% Alice sends to Carol
network3((alice, ch([msg(alice, carol, X)|AliceIn], AliceOut?)),
         (bob, ch(BobIn, BobOut?)),
         (carol, ch(CarolIn, [msg(alice, carol, X?)|CarolOut?]))) :-
    network3((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut)),
             (carol, ch(CarolIn?, CarolOut))).

%% Bob sends to Alice
network3((alice, ch(AliceIn, [msg(bob, alice, X?)|AliceOut?])),
         (bob, ch([msg(bob, alice, X)|BobIn], BobOut?)),
         (carol, ch(CarolIn, CarolOut?))) :-
    network3((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut)),
             (carol, ch(CarolIn?, CarolOut))).

%% Bob sends to Carol
network3((alice, ch(AliceIn, AliceOut?)),
         (bob, ch([msg(bob, carol, X)|BobIn], BobOut?)),
         (carol, ch(CarolIn, [msg(bob, carol, X?)|CarolOut?]))) :-
    network3((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut)),
             (carol, ch(CarolIn?, CarolOut))).

%% Carol sends to Alice
network3((alice, ch(AliceIn, [msg(carol, alice, X?)|AliceOut?])),
         (bob, ch(BobIn, BobOut?)),
         (carol, ch([msg(carol, alice, X)|CarolIn], CarolOut?))) :-
    network3((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut)),
             (carol, ch(CarolIn?, CarolOut))).

%% Carol sends to Bob
network3((alice, ch(AliceIn, AliceOut?)),
         (bob, ch(BobIn, [msg(carol, bob, X?)|BobOut?])),
         (carol, ch([msg(carol, bob, X)|CarolIn], CarolOut?))) :-
    network3((alice, ch(AliceIn?, AliceOut)),
             (bob, ch(BobIn?, BobOut)),
             (carol, ch(CarolIn?, CarolOut))).

%% === The Play ===

play_introduction :-
    %% Network switch
    network3((alice, ch(AliceNetOut?, AliceNetIn)),
             (bob, ch(BobNetOut?, BobNetIn)),
             (carol, ch(CarolNetOut?, CarolNetIn))),

    %% Agents
    agent(alice, ch(AliceUserIn?, AliceUserOut), ch(AliceNetIn?, AliceNetOut)),
    agent(bob, ch(BobUserIn?, BobUserOut), ch(BobNetIn?, BobNetOut)),
    agent(carol, ch(CarolUserIn?, CarolUserOut), ch(CarolNetIn?, CarolNetOut)),

    %% Scripts
    alice_actor(AliceUserOut?, AliceUserIn),
    bob_actor(BobUserOut?, BobUserIn),
    carol_actor(CarolUserOut?, CarolUserIn).

%% Alice: initiate cold-calls, then introduce
alice_actor(_, [msg(user, alice, connect(bob)),
               msg(user, alice, connect(carol)),
               msg(user, alice, introduce(bob, carol))]).

%% Bob: accept Alice's cold-call, then accept introduction to Carol
bob_actor([msg(agent, user, befriend(alice, Resp1))|Out1],
          [msg(user, bob, decision(yes, alice, Resp1?))|In1?]) :-
    bob_wait_intro(Out1?, In1).

bob_wait_intro([msg(agent, user, befriend_intro(alice, carol, Ch))|_],
               [msg(user, bob, accept_intro(carol, Ch?))|_]).

%% Carol: accept Alice's cold-call, then accept introduction to Bob
carol_actor([msg(agent, user, befriend(alice, Resp2))|Out2],
            [msg(user, carol, decision(yes, alice, Resp2?))|In2?]) :-
    carol_wait_intro(Out2?, In2).

carol_wait_intro([msg(agent, user, befriend_intro(alice, bob, Ch))|_],
                 [msg(user, carol, accept_intro(bob, Ch?))|_]).
