\section{Time Guards}\label{appendix:time-guards}

GLP provides time-based guards for temporal coordination of concurrent processes.

\subsection{Time Guards}

\begin{description}
\item[\texttt{wait(Duration)}] Suspends the clause for \texttt{Duration} milliseconds before proceeding. The guard succeeds after the specified time has elapsed.

\begin{verbatim}
% Client waits 100ms before sending requests
client(Requests?) :-
    wait(100) |
    Requests = [request1, request2|More?],
    client_cont(More).
\end{verbatim}

\item[\texttt{wait\_until(Timestamp)}] Suspends until the system time reaches or exceeds \texttt{Timestamp}. Useful for scheduling events at specific times.

\begin{verbatim}
% Execute at a specific timestamp
scheduled_task(Result?) :-
    wait_until(1700000000000) |
    perform_action(Result).
\end{verbatim}

\item[\texttt{get\_time(T)}] Binds \texttt{T} to the current system timestamp in milliseconds. This is a system predicate, not a guard.

\begin{verbatim}
% Record when an event occurred
log_event(Event, Time?) :- get_time(Time), store(Event?, Time?).
\end{verbatim}

\end{description}

\subsection{Temporal Coordination Example}

Time guards enable deterministic ordering of concurrent processes. In the monitor example, using \texttt{wait(100)} ensures one client's messages are processed before another's:

\begin{verbatim}
% Client 1: immediate - gets value after only its own operations
client1(V1, [add(5), add(3), value(V1?)|Xs?]) :- client1_cont(Xs).

% Client 2: delayed 100ms - gets value after all operations
client2(V2, [add(10), subtract(2), value(V2?)|Ys?]) :-
    wait(100) |
    client2_cont(Ys).

% Result: V1 = 8 (5+3), V2 = 16 (5+10+3-2)
test_monitor(V1?, V2?) :-
    client1(V1, Xs), client2(V2, Ys),
    merge(Xs?, Ys?, Zs), monitor(Zs?).
\end{verbatim}

Without the \texttt{wait(100)} guard, both clients would interleave their messages non-deterministically, and both would see the final sum of 16.
