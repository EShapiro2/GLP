================================================================================
BYTECODE INSTRUCTION COMPARISON REPORT
GLP Spec v2.16 vs Implementation (opcodes.dart)
================================================================================

INSTRUCTIONS IN SPEC (Sections 2-13): 40 total
INSTRUCTIONS IN OPCODES.DART: 36 custom instructions

================================================================================
1. INSTRUCTIONS IN SPEC BUT MISSING FROM OPCODES.DART
================================================================================

SECTION 6 - HEAD PROCESSING:
  ✗ head_nil          - Match empty list [] with argument
  ✗ head_list         - Process list structure [H|T] (equiv to head_structure './2')
  
SECTION 7 - BODY CONSTRUCTION:
  ✗ put_nil           - Place empty list in argument register
  ✗ put_list          - Begin list construction [H|T] (equiv to put_structure './2')

SECTION 8 - STRUCTURE BUILDING (core group missing):
  ✗ writer            - Process writer variable in structure (READ/WRITE mode)
  ✗ reader            - Process reader variable in structure (READ/WRITE mode)
  ✗ constant          - Process constant in structure (READ/WRITE mode)
  ✗ void              - Process n anonymous variables (READ/WRITE mode)
  
  NOTE: These are critical unification instructions for structure traversal
        They exist in spec as "structure building" but are implemented differently
        in opcodes.dart as separate categories (UnifyWriter, UnifyReader, etc.)

SECTION 9 - CONTROL FLOW:
  ✗ allocate          - Create environment frame with n permanent variables
  ✗ deallocate        - Remove current environment frame

SECTION 10 - SUSPENSION MANAGEMENT:
  ✗ reactivate        - Reactivate goals suspended on variable X
  ✗ abandon           - Mark variable as abandoned and reactivate goals

SECTION 11 - GUARD INSTRUCTIONS:
  ✗ guard             - Call guard predicate P
  ✗ ground            - Test if variable is ground (no unbound variables)
  ✗ known             - Test if variable is not a variable

SECTION 12 - SYSTEM INSTRUCTIONS:
  ✗ set               - Initialize argument position (WAM instruction)

SECTION 13 - UTILITY:
  ✗ nop               - No operation
  ✗ halt              - Terminate execution

SUBTOTAL MISSING: 17 instructions

================================================================================
2. INSTRUCTIONS IN OPCODES.DART NOT IN SPEC (or renamed/reimplemented)
================================================================================

CONTROL FLOW VARIANTS (different naming/semantics):
  + ClauseTry                  → spec: clause_try (matches)
  + Commit                     → spec: commit (matches)
  + SuspendEnd                 → spec: suspend (variant/implementation detail)
  + Proceed                    → spec: proceed (matches)
  + UnionSiAndGoto             → NO SPEC EQUIVALENT
                                  (implementation detail: discard σ̂w, Si→U, next clause)
  + ResetAndGoto               → NO SPEC EQUIVALENT
                                  (implementation detail: discard σ̂w, jump next)

BODY OPERATIONS (implemented but named differently or with extra variants):
  + BodySetConst               → partial match: put_constant (but specific variant)
  + BodySetStructConstArgs     → extra: combines put_structure + put_constant sequence
  + PutWriter                  → spec: put_writer (matches)
  + PutReader                  → spec: put_reader (matches)
  + PutConstant                → spec: put_constant (matches)
  + PutStructure               → spec: put_structure (matches)

STRUCTURE BUILDING (reimplemented as separate instructions):
  + SetWriter                  → partial: writer (but WRITE-mode only)
  + SetReader                  → partial: reader (but WRITE-mode only)
  + SetConstant                → partial: constant (but WRITE-mode only)
  + UnifyWriter                → spec: writer (READ-mode part)
  + UnifyReader                → spec: reader (READ-mode part)
  + UnifyConstant              → spec: constant (READ-mode part)
  + UnifyVoid                  → spec: void (structure position handling)

GUARD/HEAD OPERATIONS (different implementation approach):
  + HeadConstant               → spec: head_constant (matches)
  + HeadStructure              → spec: head_structure (matches)
  + HeadWriter                 → spec: head_writer (matches)
  + HeadReader                 → spec: head_reader (matches)
  + GetVariable                → spec: get_variable (matches)
  + GetValue                   → spec: get_value (matches)
  + GuardFail                  → NO SPEC EQUIVALENT (implementation detail)
  + Otherwise                  → spec: otherwise (matches)

ARGUMENT SLOT VARIANTS (runtime-encoded versions):
  + RequireWriterArg           → NO SPEC EQUIVALENT (optimization variant)
  + RequireReaderArg           → NO SPEC EQUIVALENT (optimization variant)
  + HeadBindWriterArg          → variant of head_writer for argument slots
  + GuardNeedReaderArg         → variant of guard logic for argument slots
  + BodySetConstArg            → variant of put_constant for argument slots

SPAWN/REQUEUE:
  + Spawn                      → spec: spawn (matches)
  + Requeue                    → spec: requeue (matches)
  + TailStep                   → NO SPEC EQUIVALENT
                                 (implementation detail: tail recursion budget fairness)

LEGACY (marked as "for backward compatibility"):
  + HeadBindWriter             → old variant (duplicates HeadBindWriterArg)
  + GuardNeedReader            → old variant (duplicates GuardNeedReaderArg)

LABEL:
  + Label                      → spec: label (matches)

================================================================================
3. DETAILED COMPARISON BY SECTION
================================================================================

SECTION 2: CONTROL INSTRUCTIONS
┌─────────────────────────────────────────────────────────────────────────────┐
│ Spec Instruction    │ Implementation Status                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│ clause_try          │ ✓ ClauseTry                                           │
│ clause_next         │ ✗ MISSING (partial: UnionSiAndGoto)                  │
│ suspend             │ ✓ SuspendEnd (different name)                        │
│ try_next_clause     │ ✗ MISSING                                            │
│ no_more_clauses     │ ✗ MISSING                                            │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 3: COMMIT
┌─────────────────────────────────────────────────────────────────────────────┐
│ commit              │ ✓ Commit (matches exactly)                            │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 6: HEAD PROCESSING
┌─────────────────────────────────────────────────────────────────────────────┐
│ head_constant       │ ✓ HeadConstant (matches)                              │
│ head_nil            │ ✗ MISSING (special case of head_constant)             │
│ head_structure      │ ✓ HeadStructure (matches)                             │
│ head_list           │ ✗ MISSING (special case of head_structure)            │
│ head_writer         │ ✓ HeadWriter (matches)                                │
│ head_reader         │ ✓ HeadReader (matches)                                │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 7: BODY CONSTRUCTION
┌─────────────────────────────────────────────────────────────────────────────┐
│ put_structure       │ ✓ PutStructure (matches)                              │
│ put_writer          │ ✓ PutWriter (matches)                                 │
│ put_reader          │ ✓ PutReader (matches)                                 │
│ put_constant        │ ✓ PutConstant (matches)                               │
│ put_nil             │ ✗ MISSING (special case of put_constant)              │
│ put_list            │ ✗ MISSING (special case of put_structure)             │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 8: STRUCTURE BUILDING
┌─────────────────────────────────────────────────────────────────────────────┐
│ writer              │ ✓ Partially: UnifyWriter (READ mode) + SetWriter      │
│                     │   (WRITE mode) - SPLIT INTO TWO INSTRUCTIONS         │
│ reader              │ ✓ Partially: UnifyReader (READ mode) + SetReader      │
│                     │   (WRITE mode) - SPLIT INTO TWO INSTRUCTIONS         │
│ constant            │ ✓ Partially: UnifyConstant (READ mode) +              │
│                     │   SetConstant (WRITE mode) - SPLIT INTO TWO          │
│ void                │ ✓ UnifyVoid (matches behavior)                        │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 9: CONTROL FLOW
┌─────────────────────────────────────────────────────────────────────────────┐
│ spawn               │ ✓ Spawn (matches)                                     │
│ requeue             │ ✓ Requeue (matches)                                   │
│ proceed             │ ✓ Proceed (matches)                                   │
│ allocate            │ ✗ MISSING (environment frame management)              │
│ deallocate          │ ✗ MISSING (environment frame management)              │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 10: SUSPENSION MANAGEMENT
┌─────────────────────────────────────────────────────────────────────────────┐
│ reactivate          │ ✗ MISSING (handled by runtime, not bytecode)          │
│ abandon             │ ✗ MISSING (handled by runtime, not bytecode)          │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 11: GUARD INSTRUCTIONS
┌─────────────────────────────────────────────────────────────────────────────┐
│ guard               │ ✗ MISSING (not implemented as bytecode instruction)   │
│ ground              │ ✗ MISSING (not implemented)                           │
│ known               │ ✗ MISSING (not implemented)                           │
│ otherwise           │ ✓ Otherwise (matches)                                 │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 12: SYSTEM INSTRUCTIONS
┌─────────────────────────────────────────────────────────────────────────────┐
│ get_variable        │ ✓ GetVariable (matches)                               │
│ get_value           │ ✓ GetValue (matches)                                  │
│ set                 │ ✗ MISSING (WAM frame initialization)                 │
└─────────────────────────────────────────────────────────────────────────────┘

SECTION 13: UTILITY INSTRUCTIONS
┌─────────────────────────────────────────────────────────────────────────────┐
│ nop                 │ ✗ MISSING (would not affect execution)                │
│ halt                │ ✗ MISSING (could use Proceed as fallback)             │
│ label               │ ✓ Label (matches)                                     │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
4. SUMMARY OF GAPS
================================================================================

CRITICAL MISSING INSTRUCTIONS (impact correctness):
  • writer/reader/constant/void when used in structure traversal
    (currently split into separate READ/WRITE variants)
  • clause_next (important control flow for clause selection)
  • reactivate/abandon (suspension management)
  • guard/ground/known (guard predicates)

MISSING BUT LESS CRITICAL (can be worked around):
  • head_nil/head_list (can use head_constant/head_structure)
  • put_nil/put_list (can use put_constant/put_structure)
  • allocate/deallocate (environment management not actively used)
  • nop/halt/set (utility instructions)

IMPLEMENTATION VARIANTS ADDING COMPLEXITY:
  • UnionSiAndGoto, ResetAndGoto (not in spec, implementation artifacts)
  • RequireWriterArg, RequireReaderArg, etc. (argument slot variants)
  • BodySetStructConstArgs (combined operation not in spec)
  • TailStep (fairness mechanism detail)
  • HeadBindWriter, GuardNeedReader (legacy duplicates)

================================================================================
5. ARCHITECTURAL OBSERVATIONS
================================================================================

1. SPLIT INSTRUCTIONS:
   The spec defines unified instructions (writer, reader, constant, void) that
   work in both READ and WRITE modes. The implementation splits these into:
   - Unify* variants (READ mode)
   - Set* variants (WRITE mode)
   
   This is a valid implementation choice but deviates from spec structure.

2. IMPLEMENTATION DETAILS AS INSTRUCTIONS:
   Several instructions appear to be internal implementation details rather
   than part of the normative bytecode:
   - UnionSiAndGoto (implements clause_next logic)
   - ResetAndGoto (implements jump without state update)
   - TailStep (tail recursion fairness mechanism)
   - GuardFail (failure path)

3. RUNTIME HANDLING:
   Some spec instructions are not represented in opcodes.dart because they're
   handled by the runtime directly:
   - reactivate/abandon (handled by ROQ and runtime suspension)
   - allocate/deallocate (not critical for committed-choice semantics)

4. GUARD PREDICATES:
   The spec defines guard/ground/known/otherwise as bytecode instructions.
   The implementation only has Otherwise; the others would need to be added
   or handled as special operations.

