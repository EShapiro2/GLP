# Runtime Bug: UnifyWriter Overwrites Instead of Unifying
**Date:** 2025-11-17
**Status:** Compiler bugs fixed, runtime HEAD unification bug discovered
**File:** `/Users/udi/GLP/glp_runtime/lib/bytecode/runner.dart` lines 1474-1513

---

## Executive Summary

**Bug:** When a clause variable appears multiple times in HEAD (first as reader, then as writer), the second occurrence **overwrites** the first instead of **unifying** them, causing variable bindings to be lost.

**Impact:** Clauses like `p(f(X?), g(X))` fail to bind X when matched against `p(f(A), g([]))`.

**Root cause:** `UnifyWriter` in READ mode (line 1503-1507) stores value into `clauseVars[varIndex]` without checking if a value already exists and unifying.

---

## Test Case

**Simple test:**
```prolog
% File: test_shared_var.glp
p(f(X?), g(X)).

% Query: p(f(A), g([])).
% Expected: A = []
% Actual: A = <unbound>
```

**Result:**
```
GLP> p(f(X), g([])).
1: p(f(W1001), g([])) :- true
  X = <unbound>  ← BUG! Should be []
```

**Real-world impact:**
```prolog
clause(qsort([], Rest?, Rest), true).

% Query: clause(qsort([],X,[]), Body).
% Expected: X = [], Body = true
% Actual: X = <unbound>, Body = true
```

This breaks the quicksort metainterpreter.

---

## Bytecode Analysis

**Generated bytecode for `p(f(X?), g(X))`:**
```
PC 1: ClauseTry
PC 2: HeadStructure(f, 1, A0)       # Match first arg f(...)
PC 3: UnifyVariable(X0, reader)     # X? (first occurrence) ← Bug 1 fix
PC 4: HeadStructure(g, 1, A1)       # Match second arg g(...)
PC 5: UnifyWriter(X0)               # X (subsequent occurrence) ← Bug 1 fix
PC 6: Commit
PC 7: Proceed
```

**Bytecode is CORRECT** (thanks to Bug 1 fix).

**Problem is in runtime execution at PC 5.**

---

## Execution Trace

**When matching `p(f(W1001), g([]))` against `p(f(X?), g(X))`:**

**PC 2:** `HeadStructure(f, 1, A0)`
- Sets `currentStructure = call arg 0` = `f(W1001)` (StructTerm)
- Sets `mode = READ`, `S = 0`

**PC 3:** `UnifyVariable(X0, reader)`
- READ mode, inside structure
- Executes lines 1632-1634: transforms to `UnifyReader(X0)`
- `UnifyReader` in READ mode (lines ~1300):
  - Reads `struct.args[S]` = W1001 (VarRef, unbound)
  - **Stores W1001 into clauseVars[0]**
  - Increments S to 1

**PC 4:** `HeadStructure(g, 1, A1)`
- Sets `currentStructure = call arg 1` = `g([])` (StructTerm)
- Sets `mode = READ`, `S = 0`

**PC 5:** `UnifyWriter(X0)` ← **BUG HERE**
- READ mode, inside structure
- Executes lines 1475-1513 (UnifyWriter READ mode logic)
- Line 1478-1481: `struct.args[S]` = `[]` (ConstTerm)
- Line 1503-1507:
  ```dart
  } else if (value is ConstTerm || value is StructTerm) {
    // Direct term value - store it
    cx.clauseVars[op.varIndex] = value;  // ← OVERWRITES W1001 with []!
    cx.S++;
  }
  ```
- **clauseVars[0] now contains `[]` (ConstTerm)**
- **W1001 (VarRef from call) is lost!**

**PC 6:** `Commit`
- Processes `sigmaHat` (empty in this case)
- Does NOT process clauseVars
- W1001 never gets bound to []

**Result:** Call variable X remains unbound.

---

## Root Cause

**File:** `/Users/udi/GLP/glp_runtime/lib/bytecode/runner.dart`
**Lines:** 1503-1507

```dart
} else if (value is ConstTerm || value is StructTerm) {
  // Direct term value - store it
  cx.clauseVars[op.varIndex] = value;  // ← BUG: Unconditional overwrite
  cx.S++;
}
```

**Problem:** This code **unconditionally overwrites** `clauseVars[varIndex]` without checking if a value already exists.

**What should happen:** When a clause variable appears multiple times (reader then writer), we should **unify** the existing value with the new value, not overwrite.

---

## Expected Fix

**When `UnifyWriter` executes in READ mode:**

1. Read value at position S (e.g., `[]`)
2. Check if `clauseVars[varIndex]` already has a value (e.g., W1001)
3. If yes, **UNIFY** them:
   - If existing value is VarRef: bind it to new value
   - If existing value is Term: check they unify (fail if mismatch)
4. If no, store new value

**Pseudocode:**
```dart
} else if (value is ConstTerm || value is StructTerm) {
  final existingValue = cx.clauseVars[op.varIndex];

  if (existingValue == null) {
    // First occurrence - just store
    cx.clauseVars[op.varIndex] = value;
  } else {
    // Subsequent occurrence - UNIFY
    if (existingValue is VarRef) {
      // Bind the VarRef to the new value
      _unifyInHead(cx, existingValue, value);
    } else if (existingValue is Term) {
      // Both are terms - check they match
      if (!_termsMatch(existingValue, value)) {
        _softFailToNextClause(cx, pc);
        pc = _findNextClauseTry(pc);
        continue;
      }
    }
  }
  cx.S++;
}
```

---

## Same Bug Likely Exists in Other Unify* Instructions

**UnifyReader** (lines ~1488-1502): Similar issue - may overwrite without unifying

**UnifyConstant** (somewhere in runner.dart): Check if it also overwrites

**All Unify* instructions in READ mode** need to check for existing clauseVars values and unify rather than overwrite.

---

## Question for Claude Web

**How should unification work during HEAD phase?**

In FCP/WAM, when a clause variable appears multiple times in the HEAD:
1. First occurrence: note the variable and its value from call
2. Subsequent occurrences: **unify** with the noted value

Does FCP track this in σ̂w (sigmaHat), or does it unify immediately during HEAD matching?

**Current GLP implementation:**
- Stores values in `clauseVars[]` during HEAD matching
- At Commit, processes `sigmaHat` but NOT `clauseVars`
- This loses unifications between clause variables and call variables

**Possible fixes:**

**Option A:** Unify immediately during UnifyWriter
- When clauseVars[i] already has a VarRef, bind it immediately
- Simpler but requires careful handling of suspension

**Option B:** Track unifications in sigmaHat
- When clauseVars[i] already has a value, add unification to sigmaHat
- Process all unifications at Commit
- More complex but cleaner separation

**Option C:** Track in separate unification map
- Keep clauseVars as value storage
- Maintain separate map of "clauseVar X should unify with call var Y"
- Apply at Commit

Which approach does FCP use?

---

## Files to Check

**Runtime:**
- `/Users/udi/GLP/glp_runtime/lib/bytecode/runner.dart` lines 1474-1513 (UnifyWriter READ mode)
- Same file, UnifyReader READ mode (~1300-1400)
- Same file, UnifyConstant READ mode
- Commit handler (~1671-1750)

**Specs:**
- `/Users/udi/GLP/docs/glp-runtime-spec.txt` - HEAD phase unification semantics
- `/Users/udi/GLP/docs/glp-bytecode-v216-complete.md` - Unify* instruction semantics

**Reference:**
- FCP implementation: `/Users/udi/Dropbox/Concurrent Prolog/FCP/Savannah`
- FCP paper: `/Users/udi/GLP/docs/1-s2.0-0743106689900113-main.pdf`
- WAM paper: `/Users/udi/GLP/docs/wam.pdf`

---

## Test Commands

**Simple test:**
```bash
cd /Users/udi/GLP/udi
dart glp_repl.dart <<EOF
test_shared_var.glp
p(f(X), g([])).
:quit
EOF
```

**Real-world test:**
```bash
dart glp_repl.dart <<EOF
qsort.glp
qsort([],X,[]).
:quit
EOF
```

Currently both show `X = <unbound>`, should show `X = []`.

---

## Summary

The compiler is generating correct bytecode. The runtime bug is in `UnifyWriter` (and likely other Unify* instructions) READ mode: they **overwrite** `clauseVars[varIndex]` instead of **unifying** with existing values. This breaks clauses where a variable appears multiple times in the HEAD with different modes (reader then writer).

Need to determine correct FCP/WAM approach for handling repeated clause variables during HEAD matching and implement proper unification logic.
