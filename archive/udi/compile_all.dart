/// Compile all .glp files to bytecode
///
/// Reads .glp files from glp/ and generates compiled Dart code in bin/
library;

import 'dart:io';
import 'package:glp_runtime/compiler/compiler.dart';
import 'package:glp_runtime/bytecode/runner.dart';
import 'package:glp_runtime/bytecode/opcodes.dart';

void main() async {
  print('Compiling all .glp files...\n');

  final glpDir = Directory('glp');
  final binDir = Directory('bin');

  if (!binDir.existsSync()) {
    binDir.createSync();
  }

  final compiler = GlpCompiler();
  var count = 0;

  await for (final file in glpDir.list()) {
    if (file is File && file.path.endsWith('.glp')) {
      final filename = file.path.split('/').last;
      final basename = filename.substring(0, filename.length - 4);

      print('Compiling $filename...');

      try {
        final source = await file.readAsString();
        final program = compiler.compile(source);

        // Generate Dart code for the compiled program
        final dartCode = generateDartCode(basename, program);

        // Write to bin/
        final outFile = File('bin/${basename}_compiled.dart');
        await outFile.writeAsString(dartCode);

        print('  ✓ → bin/${basename}_compiled.dart');
        count++;
      } catch (e) {
        print('  ✗ Error: $e');
      }
    }
  }

  print('\n$count files compiled successfully.');
}

String generateDartCode(String name, BytecodeProgram program) {
  final buffer = StringBuffer();

  buffer.writeln('/// Compiled bytecode for $name.glp');
  buffer.writeln('///');
  buffer.writeln('/// Generated by compile_all.dart');
  buffer.writeln('library;');
  buffer.writeln();
  buffer.writeln('import \'package:glp_runtime/bytecode/opcodes.dart\';');
  buffer.writeln('import \'package:glp_runtime/bytecode/runner.dart\';');
  buffer.writeln('import \'package:glp_runtime/runtime/terms.dart\';');
  buffer.writeln();
  buffer.writeln('BytecodeProgram get ${name}Program => BytecodeProgram([');

  // Generate code for each instruction
  for (var i = 0; i < program.code.length; i++) {
    final op = program.code[i];
    buffer.write('  ');
    buffer.write(_formatOp(op));
    buffer.writeln(',');
  }

  buffer.writeln(']);');

  return buffer.toString();
}

String _formatOp(Object op) {
  if (op is Label) {
    return 'Label(\'${op.name}\')';
  } else if (op is ClauseTry) {
    return 'ClauseTry()';
  } else if (op is ClauseNext) {
    return 'ClauseNext()';
  } else if (op is Commit) {
    return 'Commit()';
  } else if (op is Suspend) {
    return 'Suspend()';
  } else if (op is Proceed) {
    return 'Proceed()';
  } else if (op is GetVar) {
    return 'GetVar(${op.argIndex}, ${op.varSlot})';
  } else if (op is SetClauseVar) {
    return 'SetClauseVar(${op.slot}, ${_formatTerm(op.value)})';
  } else if (op is Execute) {
    return 'Execute(\'${op.name}\', [${op.argSlots.join(', ')}])';
  } else if (op is HeadStructure) {
    return 'HeadStructure(${op.argIndex}, \'${op.functor}\', ${op.arity})';
  } else if (op is HeadWriter) {
    return 'HeadWriter(${op.argIndex})';
  } else if (op is HeadReader) {
    return 'HeadReader(${op.argIndex})';
  } else if (op is HeadConstant) {
    return 'HeadConstant(${op.argIndex}, ${_formatValue(op.value)})';
  } else if (op is WriterInstr) {
    return 'WriterInstr(${op.varSlot})';
  } else if (op is ReaderInstr) {
    return 'ReaderInstr(${op.varSlot})';
  } else if (op is ConstantInstr) {
    return 'ConstantInstr(${_formatValue(op.value)})';
  } else if (op is VoidInstr) {
    return 'VoidInstr(${op.count})';
  } else if (op is Guard) {
    return 'Guard(${op.varIndex})';
  } else if (op is Ground) {
    return 'Ground(${op.varIndex})';
  } else if (op is Known) {
    return 'Known(${op.varIndex})';
  } else if (op is Otherwise) {
    return 'Otherwise()';
  } else if (op is IfWriter) {
    return 'IfWriter(${op.varIndex})';
  } else if (op is IfReader) {
    return 'IfReader(${op.varIndex})';
  } else if (op is PutStructure) {
    return 'PutStructure(${op.varSlot}, \'${op.functor}\', ${op.arity})';
  } else if (op is PutWriter) {
    return 'PutWriter(${op.varSlot})';
  } else if (op is PutReader) {
    return 'PutReader(${op.varSlot})';
  } else if (op is PutConstant) {
    return 'PutConstant(${op.varSlot}, ${_formatValue(op.value)})';
  } else if (op is Spawn) {
    return 'Spawn(${op.arity})';
  } else if (op is Requeue) {
    return 'Requeue()';
  } else {
    return op.toString();
  }
}

String _formatTerm(Object? term) {
  if (term is ConstTerm) {
    return 'ConstTerm(${_formatValue(term.value)})';
  } else if (term is WriterTerm) {
    return 'WriterTerm(${term.writerId})';
  } else if (term is ReaderTerm) {
    return 'ReaderTerm(${term.readerId})';
  } else if (term is StructureTerm) {
    final args = term.args.map(_formatTerm).join(', ');
    return 'StructureTerm(\'${term.functor}\', [${args}])';
  } else {
    return _formatValue(term);
  }
}

String _formatValue(Object? value) {
  if (value == null) {
    return 'null';
  } else if (value is String) {
    return '\'${value.replaceAll('\'', '\\\'')}\'';
  } else if (value is int || value is double || value is bool) {
    return value.toString();
  } else if (value is List) {
    final items = value.map(_formatValue).join(', ');
    return '[${items}]';
  } else {
    return '\'$value\'';
  }
}
