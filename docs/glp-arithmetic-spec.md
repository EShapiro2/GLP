# GLP Arithmetic Specification (Normative)

**Version**: 2.0
**Status**: Draft
**Date**: 2025-11-21

## 1. Overview

GLP provides arithmetic operations in two contexts:
1. **Guard Arithmetic**: Expressions in guard position (e.g., `X? + Y? > 10`)
2. **Body Arithmetic**: Assignment via `:=` operator (e.g., `Z := X? + Y?`)

Both follow FCP's model but with distinct semantics based on context.

---

## 2. Prerequisites

Read **`glp-predicates-taxonomy.md`** first for definitions of:
- Guard Predicates
- Guard Kernel Predicates
- Body Kernel Predicates
- System Predicates

---

## 3. Guard Arithmetic

### 3.1 Syntax

Arithmetic expressions can appear in guard position:

```glp
test(...) :- X? + Y? > 10 | ...
test(...) :- X? * 2 =:= Y? - 5 | ...
test(...) :- (X? + Y?) * Z? < 100 | ...
```

### 3.2 Compilation Model

**Source**:
```glp
test(X, Y, Z?) :- X? < Y? + 10 | Z = ok.
```

**Compiled Guard**:
```
guard_add(Y?, 10, Temp)    % Guard kernel: Temp = Y + 10
X? < Temp?                 % Guard predicate: compare
```

The compiler:
1. Identifies arithmetic subexpressions in guards
2. Generates guard kernel calls to evaluate them
3. Allocates temporary variables for results
4. Generates comparison guard predicates

### 3.3 Guard Kernel Semantics

**Three-valued**: success/suspend/fail

**Key Restriction**: Operands must be bound to **numeric values**, not expression structures.

**Behavior** for `guard_add(X?, Y?, Result)`:

| X Value | Y Value | Result |
|---------|---------|--------|
| 5 | 3 | Result = 8, **succeed** |
| unbound | any | **Suspend** on X |
| any | unbound | **Suspend** on Y |
| atom | 3 | **Fail** (type error) |
| +(1,2) | 3 | **Fail** (expression, not number) |
| 5 | "string" | **Fail** (type error) |

**No Recursive Evaluation**: Guard kernels do not recursively evaluate expression structures. If an operand is bound to `+(1,2)`, the guard kernel **fails** (it's not a number).

**Why**: Guards must be efficient and decidable. Recursive evaluation in guards would complicate suspension semantics and performance.

### 3.4 Guard Kernel Predicates

**Available Guard Kernels** (internal, compiler-generated):

| Kernel | Operation |
|--------|-----------|
| `guard_add(X?, Y?, R)` | R = X + Y |
| `guard_sub(X?, Y?, R)` | R = X - Y |
| `guard_mul(X?, Y?, R)` | R = X * Y |
| `guard_div(X?, Y?, R)` | R = X / Y (fails if Y = 0) |
| `guard_mod(X?, Y?, R)` | R = X mod Y (fails if Y = 0) |

**Note**: These are **not accessible to users** - only generated by compiler.

### 3.5 Type Coercion in Guards

Same as body arithmetic:
- Integer op Integer → Integer (except `/` → Float)
- Integer op Float → Float
- Float op Integer → Float
- Float op Float → Float

### 3.6 Examples

```glp
% Simple guard arithmetic
test1(X, Y, Z?) :- X? + Y? > 10 | Z = ok.
% Compiles: guard_add(X?, Y?, T1), T1? > 10

% Nested expression
test2(X, Y, Z?) :- X? * 2 + Y? < 100 | Z = ok.
% Compiles:
%   guard_mul(X?, 2, T1)
%   guard_add(T1?, Y?, T2)
%   T2? < 100

% Complex guard
test3(X, Y, Z, R?) :- (X? + Y?) * Z? =:= 100 | R = ok.
% Compiles:
%   guard_add(X?, Y?, T1)
%   guard_mul(T1?, Z?, T2)
%   T2? =:= 100
```

### 3.7 Guard Arithmetic Failure

**Failure is Normal**: Guards can fail, causing clause to be skipped.

```glp
% Clause 1: Requires X, Y to be numbers
compute1(X, Y, Z?) :- X? + Y? > 10 | Z = big.

% Clause 2: Fallback
compute1(X, Y, Z?) :- otherwise | Z = unknown.

% Query: compute1(atom, 5, R)
% Result: R = unknown (clause 1 guard failed, clause 2 matched)
```

---

## 4. Body Arithmetic (`:=` Operator)

### 4.1 What is `:=`?

**`:=` is a System Predicate**: It's a regular GLP program defined by clauses, predefined and shipped with GLP.

**Key Properties**:
1. **Regular GLP clauses** - not a special bytecode instruction
2. **Special access** to body kernel predicates (`add/3`, `mul/3`, etc.) that user programs cannot access
3. **Built-in guards** ensure body kernels called safely
4. **Assumed predefined** - users don't define it, loaded from trusted stdlib

**Access Control**: System predicates like `:=` are loaded from a trusted location (`stdlib/`) and granted access to an internal registry of body kernel predicates. User programs do not have this access - if a user program tries to call `add(X, Y, Z)` directly, it will fail (predicate not found).

### 4.2 Syntax

```glp
WriterVar := Expression
```

**Context**: Body goals only (after `|`).

**Precedence**: 700 (same as comparison operators).

**Associativity**: Right-associative.

### 4.3 `:=` Definition (Conceptual)

The `:=` system predicate is defined with multiple clauses using infix notation:

```glp
% Addition - operands are numbers
Result := X? + Y? :-
  number(X?), number(Y?) |
  add(X?, Y?, Result).        % Body kernel - safe

% Addition - recursive evaluation needed
Result := X? + Y? :-
  otherwise |
  X1 := X?,                   % Recursively evaluate X
  Y1 := Y?,                   % Recursively evaluate Y
  Result := X1? + Y1?.        % Recurse with evaluated operands

% Subtraction - operands are numbers
Result := X? - Y? :-
  number(X?), number(Y?) |
  sub(X?, Y?, Result).

% Subtraction - recursive evaluation
Result := X? - Y? :-
  otherwise |
  X1 := X?,
  Y1 := Y?,
  Result := X1? - Y1?.

% Similar clauses for *, /, //, mod

% Unary negation
Result := -X? :-
  number(X?) |
  neg(X?, Result).

Result := -X? :-
  otherwise |
  X1 := X?,
  Result := -X1?.

% Functions: sqrt, sin, cos, etc.
Result := sqrt(X?) :-
  number(X?), X? >= 0 |
  sqrt_kernel(X?, Result).

Result := sqrt(X?) :-
  number(X?), X? < 0 |
  abort("sqrt of negative number").

Result := sqrt(X?) :-
  otherwise |
  X1 := X?,
  Result := sqrt(X1?).

% ... similar patterns for all operators and functions
```

**Key Points**:
1. First clause for each operator: guards ensure operands are numbers → call body kernel
2. Second clause: `otherwise` → recursive evaluation
3. Safety from **`:=`'s own clauses**, not user's guards

### 4.4 Body Kernel Semantics

**Two-valued**: success/abort

**Precondition**: All operands must be bound to numbers.

**Behavior** for `add(X?, Y?, Result)`:

| X Value | Y Value | Behavior |
|---------|---------|----------|
| 5 | 3 | Result = 8, **succeed** |
| unbound | any | **ABORT** "Unbound reader X" |
| any | unbound | **ABORT** "Unbound reader Y" |
| atom | 3 | **ABORT** "Type error: atom not a number" |
| +(1,2) | 3 | **ABORT** "Type error: expression not a number" |
| 5 | "string" | **ABORT** "Type error: string not a number" |

**Why Abort**: Body kernels execute post-commit. Failure indicates programming error, not a normal condition.

**Who Ensures Safety**: The `:=` system predicate's guards ensure body kernels only called with safe inputs.

**Compiler Verification**: The compiler should perform static type analysis to verify that arithmetic operations will not cause body kernel aborts. Body kernel abort conditions (type errors, division by zero with constant operands, domain errors) should be caught at compile time whenever possible. Runtime aborts are safety mechanisms for programming errors, not expected execution paths.

### 4.5 Recursive Evaluation in Body

Unlike guard arithmetic, body arithmetic **recursively evaluates expression structures**:

```glp
test(X, Y, Z?) :-
  true |
  Z := X? + Y?.

% Query: test(+(1,2), 3, Z)
% Execution:
%   1. Z := +(1,2) + 3
%   2. First := clause fails (+(1,2) not a number)
%   3. Second := clause: X1 := +(1,2)
%   4. Recursively: X1 := 1 + 2 → X1 = 3
%   5. Y1 := 3 → Y1 = 3
%   6. Z := 3 + 3 → Z = 6
```

**Key Difference**:
- **Guard**: `X? + Y?` where X = +(1,2) → **fail** (not a number)
- **Body**: `Z := X? + Y?` where X = +(1,2) → **recurse** → Z = (1+2) + Y

### 4.6 User Code is Simple

Users don't see the complexity - they just use `:=`:

```glp
% No guards needed - := handles everything
factorial(N, F?) :-
  N? > 0 |
  N1 := N? - 1,           % Safe
  factorial(N1?, F1),
  F := N? * F1?.          % Safe
```

**What happens**:
1. `N1 := N? - 1`: calls `:=`, which checks if N is number, calls `sub/3` body kernel
2. If N unbound → `:=` suspends (via recursive evaluation)
3. If N is atom → `:=` eventually aborts (after full evaluation shows non-numeric)

### 4.7 Optional User Guards for Optimization

Users can provide guards to help compiler optimize:

```glp
% Version 1: No guards - works but spawns :=
compute1(X, Y, Z?) :-
  true |
  Z := X? + Y?.

% Version 2: Guards enable future optimization
compute2(X, Y, Z?) :-
  number(X?), number(Y?) |
  Z := X? + Y?.    % Future: compiler could inline add/3
```

**Current**: Both work identically.

**Future**: Compiler sees `number(X?), number(Y?)` guards, knows operands are numbers, could generate direct `add(X?, Y?, Z)` body kernel call instead of spawning `:=` goal.

---

## 5. Supported Operators

### 5.1 Binary Operators

| Operator | Name | Body Kernel | Notes |
|----------|------|-------------|-------|
| `+` | Addition | `add(X?, Y?, R)` | Int/Float |
| `-` | Subtraction | `sub(X?, Y?, R)` | Int/Float |
| `*` | Multiplication | `mul(X?, Y?, R)` | Int/Float |
| `/` | Division | `div(X?, Y?, R)` | Always Float; abort if Y=0 |
| `mod` | Modulo | `mod(X?, Y?, R)` | Integer only; abort if Y=0 |
| `//` | Integer division | `idiv(X?, Y?, R)` | Integer result; abort if Y=0 |

### 5.2 Unary Operators

| Operator | Name | Body Kernel | Notes |
|----------|------|-------------|-------|
| `-X` | Negation | `neg(X?, R)` | Unary minus |
| `abs(X)` | Absolute value | `abs(X?, R)` | Int/Float |

### 5.3 Mathematical Functions

| Function | Body Kernel | Notes |
|----------|-------------|-------|
| `sqrt(X)` | `sqrt_kernel(X?, R)` | Abort if X < 0 |
| `sin(X)` | `sin_kernel(X?, R)` | Float result |
| `cos(X)` | `cos_kernel(X?, R)` | Float result |
| `tan(X)` | `tan_kernel(X?, R)` | Float result |
| `exp(X)` | `exp_kernel(X?, R)` | e^X |
| `ln(X)` | `ln_kernel(X?, R)` | Natural log; abort if X ≤ 0 |
| `log(X)` | `log10_kernel(X?, R)` | Base-10 log; abort if X ≤ 0 |
| `pow(X, Y)` | `pow_kernel(X?, Y?, R)` | X^Y |

### 5.4 Type Conversions

| Function | Body Kernel | Notes |
|----------|-------------|-------|
| `integer(X)` | `integer_kernel(X?, R)` | Truncate to int |
| `real(X)` | `real_kernel(X?, R)` | Convert to float |
| `round(X)` | `round_kernel(X?, R)` | Round to nearest int |
| `floor(X)` | `floor_kernel(X?, R)` | Round down |
| `ceil(X)` | `ceil_kernel(X?, R)` | Round up |

### 5.5 Operator Precedence (High to Low)

1. Function calls: `sqrt(...)`, `sin(...)` (highest)
2. Unary: `-X`
3. `*`, `/`, `mod`, `//`
4. `+`, `-`
5. `:=` (lowest)

---

## 6. Type System

### 6.1 Numeric Types

**Integer**: Dart `int` (64-bit signed)
- Literals: `0`, `42`, `-17`

**Float**: Dart `double` (IEEE 754)
- Literals: `3.14`, `-0.5`, `2.0`

### 6.2 Type Coercion

| Operation | Operands | Result Type |
|-----------|----------|-------------|
| `+`, `-`, `*` | Int, Int | Integer |
| `/` | Int, Int | Float (always) |
| `//` | Int, Int | Integer |
| `mod` | Int, Int | Integer |
| Any | Int, Float | Float |
| Any | Float, Int | Float |
| Any | Float, Float | Float |

### 6.3 Type Errors

If after full recursive evaluation, an operand is not numeric → **abort**.

```glp
% Aborts after evaluation shows atom
test1(Z?) :- true | Z := atom + 1.
% Result: ABORT "Type error: atom not a number"

% Aborts after recursive evaluation
test2(X, Z?) :- true | Z := X? + 1.
% Query: test2(atom, Z)
% Result: ABORT "Type error: atom not a number"
```

---

## 7. Comparison: Guards vs Body

### 7.1 Key Differences

| Aspect | Guard Arithmetic | Body Arithmetic (`:=`) |
|--------|------------------|------------------------|
| **Implementation** | Guard kernel predicates | System predicate using body kernels |
| **Operand Requirements** | Must be numeric values | Can be expressions (recursive eval) |
| **Unbound Variable** | Suspend | Suspend (via recursive :=) |
| **Non-numeric** | Fail (try next clause) | Abort (programming error) |
| **Expression Structures** | Fail (no recursion) | Evaluate recursively |
| **Context** | Pre-commit | Post-commit |

### 7.2 Examples Showing Difference

**Guard**:
```glp
test1(X, Y?) :- X? + 1 > 10 | Y = ok.

% Query: test1(+(5,6), Y)
% guard_add(+(5,6), 1, Temp) → FAIL (+(5,6) not a number)
% Result: Goal fails
```

**Body**:
```glp
test2(X, Y?) :- true | Y := X? + 1.

% Query: test2(+(5,6), Y)
% Y := +(5,6) + 1
% Recursive: X1 := +(5,6) → X1 := 5 + 6 → X1 = 11
% Y := 11 + 1 → Y = 12
% Result: Y = 12
```

---

## 8. Complete Examples

### 8.1 Factorial

```glp
% Base cases
factorial(0, 1).
factorial(1, 1).

% Recursive case
factorial(N, F?) :-
  N? > 1 |
  N1 := N? - 1,
  factorial(N1?, F1),
  F := N? * F1?.

% Query: factorial(5, F)
% Result: F = 120
```

### 8.2 Fibonacci

```glp
% Base cases
fib(0, 0).
fib(1, 1).

% Recursive case
fib(N, F?) :-
  N? > 1 |
  N1 := N? - 1,
  N2 := N? - 2,
  fib(N1?, F1),
  fib(N2?, F2),
  F := F1? + F2?.

% Query: fib(10, F)
% Result: F = 55
```

### 8.3 Quadratic Formula

```glp
% Solve ax^2 + bx + c = 0
quadratic(A, B, C, X1?, X2?) :-
  Disc := B? * B? - 4 * A? * C?,
  Disc? >= 0 |
  SqrtDisc := sqrt(Disc?),
  X1 := (-(B?) + SqrtDisc?) / (2 * A?),
  X2 := (-(B?) - SqrtDisc?) / (2 * A?).

quadratic(A, B, C, none, none) :-
  Disc := B? * B? - 4 * A? * C?,
  Disc? < 0 |
  true.
```

### 8.4 Expression Evaluation

```glp
% Evaluates nested expression
eval_expr(Expr, Result?) :-
  true |
  Result := Expr?.

% Query: eval_expr(+(*(2,3), /(8,2)), R)
% Execution:
%   R := +(*(2,3), /(8,2))
%   Evaluates *(2,3) → 6
%   Evaluates /(8,2) → 4.0
%   R := 6 + 4.0 → R = 10.0
```

---

## 9. Error Handling

### 9.1 Guard Arithmetic Errors

**Suspension**: Unbound operand → goal suspends
```glp
test(X, Y?) :- X? + 1 > 10 | Y = ok.
% Query: test(Unbound, Y)
% Result: Goal suspends on Unbound
```

**Failure**: Type error or non-numeric → guard fails, try next clause
```glp
test1(X, Y?) :- X? + 1 > 10 | Y = ok.
test1(X, Y?) :- otherwise | Y = unknown.

% Query: test1(atom, Y)
% Result: Y = unknown (first clause guard failed)
```

### 9.2 Body Arithmetic Errors

**Suspension**: Unbound during recursive evaluation → suspend
```glp
test(X, Y?) :- true | Y := X? + 1.
% Query: test(Unbound, Y)
% Y := Unbound + 1
% Recursive: X1 := Unbound → suspends
```

**Abort**: Type error after full evaluation → abort
```glp
test(Y?) :- true | Y := atom + 1.
% Result: ABORT "Type error: atom not a number"
```

**Abort**: Domain error → abort
```glp
test(Y?) :- true | Y := 5 / 0.
% Result: ABORT "Division by zero"

test(Y?) :- true | Y := sqrt(-4).
% Result: ABORT "sqrt of negative number"
```

---

## 10. Implementation Model

### 10.1 Guard Kernels Implementation

```dart
// Guard kernel: three-valued
GuardResult guardAddKernel(Runtime rt, Term left, Term right, Term result) {
  // Dereference operands
  final leftVal = rt.deref(left);
  final rightVal = rt.deref(right);

  // Check if unbound → suspend
  if (leftVal is UnboundVar) return GuardResult.suspend([leftVal.id]);
  if (rightVal is UnboundVar) return GuardResult.suspend([rightVal.id]);

  // Check if numeric
  if (leftVal is! num) return GuardResult.fail;
  if (rightVal is! num) return GuardResult.fail;

  // Compute
  final sum = leftVal + rightVal;
  rt.bind(result, sum);
  return GuardResult.success;
}
```

### 10.2 Body Kernels Implementation

```dart
// Body kernel: two-valued (success or abort)
void addBodyKernel(Runtime rt, Term left, Term right, Term result) {
  // Dereference operands
  final leftVal = rt.deref(left);
  final rightVal = rt.deref(right);

  // Check if unbound → ABORT
  if (leftVal is UnboundVar) {
    rt.abort("Unbound reader in add/3: left operand");
  }
  if (rightVal is UnboundVar) {
    rt.abort("Unbound reader in add/3: right operand");
  }

  // Check if numeric → ABORT if not
  if (leftVal is! num) {
    rt.abort("Type error in add/3: left operand not a number");
  }
  if (rightVal is! num) {
    rt.abort("Type error in add/3: right operand not a number");
  }

  // Compute and bind
  final sum = leftVal + rightVal;
  rt.bind(result, sum);
  // Always succeeds if we get here
}
```

### 10.3 `:=` System Predicate

Precompiled as regular GLP bytecode, loaded at startup:

```bash
# Compile := definition
glp_compiler stdlib/assign.glp -o stdlib/assign.glpc

# Runtime loads it
runtime.loadSystemPredicate('stdlib/assign.glpc');
```

---

## 11. Future Extensions

### 11.1 Bitwise Operations

```glp
X := Y? /\ Z?        % Bitwise AND
X := Y? \/ Z?        % Bitwise OR
X := Y? xor Z?       % Bitwise XOR
X := ~Y?             % Bitwise NOT
X := Y? << Z?        % Left shift
X := Y? >> Z?        % Right shift
```

### 11.2 Additional Functions

```glp
X := min(Y?, Z?)     % Minimum
X := max(Y?, Z?)     % Maximum
X := atan2(Y?, Z?)   % Two-argument arctangent
X := hypot(Y?, Z?)   % Hypotenuse
```

### 11.3 Compile-Time Evaluation

If all operands are constants, evaluate at compile time:

```glp
% Source
test(X?) :- true | X := 2 + 3 * 4.

% Optimized bytecode
test(X?) :- true | X = 14.
```

### 11.4 User Guards → Inline Optimization

```glp
% With guards, compiler can inline body kernel
compute(X, Y, Z?) :-
  number(X?), number(Y?) |
  Z := X? + Y?.    % Compiler: inline add(X?, Y?, Z) instead of spawn :=
```

---

## 12. References

1. **Predicates Taxonomy**: `glp-predicates-taxonomy.md` - Four predicate categories
2. **FCP Implementation**: Guard kernels (Ask/3) vs body operations
3. **GLP SRSW**: Simplifies body kernels (no unification conflicts)

---

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-11-21 | Initial specification |
| 2.0 | 2025-11-21 | Revised: := as system predicate, guard vs body distinction clarified |

---

**End of Specification**
