# GLP Predicates Taxonomy (Normative)

**Version**: 1.0
**Status**: Draft
**Date**: 2025-11-21

## 1. Overview

GLP distinguishes between four categories of predicates based on their implementation, context of use, and semantics. This taxonomy is fundamental to understanding GLP's execution model and the division between user-visible and internal mechanisms.

---

## 2. The Four Categories

### 2.1 Guard Predicates

**Definition**: User-facing predicates that can be used in guard position (before `|`) to test conditions.

**Implementation**: Runtime-implemented (not defined in GLP).

**Semantics**: Three-valued (success/suspend/fail).

**Purpose**: Test properties of terms without binding variables.

**Examples**:
- `number(X?)` - Test if X is bound to a number
- `ground(X?)` - Test if X is fully ground (no unbound variables)
- `atom(X?)` - Test if X is an atom
- `X? > Y?` - Arithmetic comparison
- `X? =:= Y?` - Arithmetic equality

**Usage**:
```glp
% Guard predicates before |
factorial(N, F?) :-
  number(N?),        % Guard predicate
  N? > 0 |           % Guard predicate
  ...
```

**Failure Behavior**: Guard fails → try next clause (backtrack).

---

### 2.2 Guard Kernel Predicates

**Definition**: Internal predicates generated by the compiler for implementing complex guard conditions, particularly arithmetic expressions in guards.

**Implementation**: Runtime-implemented (not defined in GLP).

**Visibility**: **Not accessible to programmers** - compiler-generated only.

**Semantics**: Three-valued (success/suspend/fail).

**Purpose**: Evaluate arithmetic expressions within guards, creating temporary variables.

**Key Restriction**: Operands must be bound to **numeric values** (not expression structures). No recursive evaluation.

**Behavior**:
- Operand unbound → **suspend**
- Operand bound to number → compute, **succeed**
- Operand bound to non-number (atom, expression structure) → **fail**

**Example Compilation**:

**Source**:
```glp
test(X, Y, Z?) :- X? < Y? + 10 | Z = ok.
```

**Compiled guard**:
```
guard_add(Y?, 10, Temp)    % Guard kernel: creates Temp = Y + 10
X? < Temp?                 % Guard predicate: compares X with Temp
```

**Guard Kernel Examples**:
- `guard_add(X?, Y?, Result)` - Addition for guards
- `guard_sub(X?, Y?, Result)` - Subtraction for guards
- `guard_mul(X?, Y?, Result)` - Multiplication for guards
- `guard_div(X?, Y?, Result)` - Division for guards

**Detailed Semantics** for `guard_add(X?, Y?, Result)`:

| X value | Y value | Result |
|---------|---------|--------|
| 5 | 3 | Result = 8, succeed |
| unbound | 3 | Suspend |
| 5 | unbound | Suspend |
| atom | 3 | Fail |
| +(1,2) | 3 | Fail (expression, not number) |
| 5 | "hello" | Fail |

---

### 2.3 Body Kernel Predicates

**Definition**: Runtime-implemented predicates for body operations that execute inline (not spawned) and must succeed.

**Implementation**: Runtime-implemented (not defined in GLP).

**Visibility**: **Not accessible to user programs** - only accessible to system predicates (predefined GLP code shipped with the runtime).

**Access Control**: User programs cannot call body kernels. Only system predicates have access via a separate internal registry.

**Context**: Body only (after `|`), post-commit.

**Semantics**: Two-valued (success/abort).

**Execution Model**:
- Execute inline (not spawned as separate goal)
- Must succeed
- Failure → abort computation with error report

**Key Guarantee**: Called only when preconditions are satisfied (ensured by caller's guards).

**Failure Causes**:
- Unbound operand → **abort** "Unbound reader in body kernel"
- Type error (non-numeric operand) → **abort** "Type error in body kernel"
- Domain error (division by zero) → **abort** "Domain error in body kernel"

**Examples**:
- `add(X?, Y?, Z)` - Addition: Z = X + Y
- `sub(X?, Y?, Z)` - Subtraction: Z = X - Y
- `mul(X?, Y?, Z)` - Multiplication: Z = X * Y
- `div(X?, Y?, Z)` - Division: Z = X / Y (float result)
- `mod(X?, Y?, Z)` - Modulo: Z = X mod Y
- `write(Term)` - Write to stdout
- `bind(Writer, Value)` - Bind writer variable to value

**Usage** (internal):
```glp
% System predicate := uses body kernels
':='(Result, +(X?, Y?)) :-
  number(X?), number(Y?) |    % Guards ensure preconditions
  add(X?, Y?, Result).        % Body kernel - guaranteed to succeed
```

**Detailed Semantics** for `add(X?, Y?, Result)`:

| X value | Y value | Behavior |
|---------|---------|----------|
| 5 | 3 | Result = 8, succeed |
| unbound | 3 | **ABORT** "Unbound reader X" |
| 5 | unbound | **ABORT** "Unbound reader Y" |
| atom | 3 | **ABORT** "Type error: atom is not a number" |
| 5 | "hello" | **ABORT** "Type error: string is not a number" |

**No suspension**: Body kernels expect all preconditions met.

---

### 2.4 System Predicates

**Definition**: Predicates predefined by GLP clauses, shipped with the standard library, that users do not need to define themselves.

**Implementation**: **Regular GLP programs** - defined by clauses written in GLP.

**Visibility**: Fully accessible to programmers (can be used, not redefined).

**Key Characteristic**: Have special access to body kernel predicates that regular user programs cannot access.

**Access Privilege**: System predicates are loaded from a trusted location and granted access to the internal body kernel registry. User programs do not have this access.

**Purpose**: Provide high-level abstractions over body kernels with proper guard checks.

**Examples**:
- `:=/2` - Arithmetic assignment
- `append/3` - List concatenation
- `length/2` - List length
- `reverse/2` - List reversal

**Safety Guarantee**: System predicates' own clauses contain guards that ensure body kernels are called safely.

**Example: `:=` Definition**:

```glp
% Clause 1: Both operands are numbers - use body kernel directly
':='(Result, +(X?, Y?)) :-
  number(X?), number(Y?) |    % Guard ensures body kernel precondition
  add(X?, Y?, Result).        % Body kernel call is safe

% Clause 2: Operands may be expressions - recursive evaluation
':='(Result, +(X?, Y?)) :-
  otherwise |                 % No guard - fallback clause
  X1 := X?,                   % Recursively evaluate X
  Y1 := Y?,                   % Recursively evaluate Y
  Result := X1? + Y1?.        % Recurse with evaluated operands

% Similar clauses for -, *, /, mod, etc.
```

**Key Point**: The safety comes from **`:=`'s own clauses**, not from user's code.

**User Code**:
```glp
% No guards needed - := handles everything safely
compute(X, Y, Z?) :-
  true |
  Z := X? + Y?.    % Safe: := clauses ensure body kernels called correctly
```

**Future Optimization**: User-provided guards may enable compiler optimizations:
```glp
% Guards allow compiler to call add/3 inline instead of spawning :=
compute(X, Y, Z?) :-
  number(X?), number(Y?) |
  Z := X? + Y?.    % Compiler can optimize: inline add(X?, Y?, Z)
```

---

## 3. Comparison Table

| Category | Implementation | Visibility | Context | Semantics | Failure |
|----------|---------------|------------|---------|-----------|---------|
| **Guard Predicates** | Runtime | User-visible | Guards | 3-valued | Try next clause |
| **Guard Kernels** | Runtime | Internal only | Guards (compiler) | 3-valued | Try next clause |
| **Body Kernels** | Runtime | Internal only | Body (via system preds) | 2-valued | Abort |
| **System Predicates** | GLP clauses | User-visible | Any | 3-valued | Try next clause |

---

## 4. Execution Context

### 4.1 Guard Position (Before `|`)

**Available to User**:
- Guard predicates: `number(X?)`, `X? > Y?`

**Generated by Compiler**:
- Guard kernels: `guard_add(Y?, 10, Temp)` for `Y? + 10`

**Execution Characteristics**:
- Three-valued semantics throughout
- Failure → backtrack to next clause
- No permanent effects (pre-commit)

### 4.2 Body Position (After `|`)

**Available to User**:
- System predicates: `Z := X? + Y?`
- User-defined predicates
- Spawned goals

**Internal (Used by System Predicates)**:
- Body kernels: `add(X?, Y?, Z)`

**Execution Characteristics**:
- Post-commit (no backtracking)
- Body kernels must succeed or abort
- System predicates can fail (try next clause)

---

## 5. Design Rationale

### 5.1 Why Four Categories?

**Separation of Concerns**:
- **Guard predicates** - User tests (safe, reversible)
- **Guard kernels** - Compiler-generated guards (internal optimization)
- **Body kernels** - Low-level operations (unsafe, must be wrapped)
- **System predicates** - Safe high-level wrappers (user interface)

**Safety Model**:
- Body kernels are dangerous (abort on error)
- System predicates wrap them safely with guards
- Users work with safe abstractions
- Compiler uses internal mechanisms for efficiency

### 5.2 Why Hide Body Kernels?

**Risks of Direct Exposure**:
```glp
% DANGEROUS if body kernels were exposed
unsafe(X, Y, Z?) :-
  true |
  add(X?, Y?, Z).    % ABORT if X or Y unbound or non-numeric
```

**Safe via System Predicates**:
```glp
% SAFE - := handles preconditions
safe(X, Y, Z?) :-
  true |
  Z := X? + Y?.    % := clauses ensure safety
```

### 5.3 Why Guard Kernels vs Body Kernels?

**Different Semantics Needed**:

**Guard Context** (pre-commit):
- Must handle unbound variables → suspend
- Must handle type errors → fail (try next clause)
- Needs three-valued semantics

**Body Context** (post-commit):
- Expects preconditions met
- Errors indicate programming bugs → abort
- Two-valued semantics sufficient

**Same Operation, Different Context**:
```glp
% Guard context - uses guard kernel (can suspend/fail)
test1(...) :- X? + Y? > 10 | ...

% Body context - uses body kernel (must succeed)
test2(...) :- number(X?), number(Y?) | Z := X? + Y?.
```

---

## 6. Guidelines for Users

### 6.1 What Users Work With

**In Guards**:
- Use guard predicates: `number(X?)`, `ground(X?)`, `X? > Y?`
- Write arithmetic expressions: `X? + Y? > 10` (compiler handles rest)

**In Bodies**:
- Use system predicates: `Z := X? + Y?`
- Define your own predicates with clauses
- Trust system predicates to handle safety

### 6.2 What Users Don't See

**Internal Mechanisms**:
- Guard kernel predicates (compiler-generated)
- Body kernel predicates (used by system predicates)

**Why Hidden**:
- Prevent unsafe usage
- Enable compiler optimizations
- Maintain abstraction boundaries

### 6.3 Optional Guards for Optimization

```glp
% Version 1: No guards - safe but spawns :=
compute1(X, Y, Z?) :-
  true |
  Z := X? + Y?.

% Version 2: Guards enable future optimization
compute2(X, Y, Z?) :-
  number(X?), number(Y?) |
  Z := X? + Y?.    % Future: compiler could inline add/3
```

**Current Behavior**: Both versions work safely.

**Future Optimization**: Version 2's guards inform compiler that operands are numbers, enabling inline body kernel call instead of spawning `:=`.

---

## 7. Implementation Notes

### 7.1 Runtime Registry

**Guard Predicates Registry**:
```dart
guardRegistry.register('number', numberGuard);
guardRegistry.register('ground', groundGuard);
guardRegistry.register('>', greaterGuard);
```

**Guard Kernel Registry** (internal):
```dart
guardKernelRegistry.register('guard_add', guardAddKernel);
guardKernelRegistry.register('guard_mul', guardMulKernel);
```

**Body Kernel Registry** (internal, restricted access):
```dart
// Internal registry - only accessible to system predicates
bodyKernelRegistry.register('add', addBodyKernel);
bodyKernelRegistry.register('mul', mulBodyKernel);
bodyKernelRegistry.register('write', writeBodyKernel);

// Access control: body kernels not in public predicate lookup
// User goal "add(X, Y, Z)" → fails (not found in user registry)
// System predicate calling add/3 → succeeds (has internal registry access)
```

**System Predicates**:
Loaded from trusted location at startup with special access:
```dart
// Load system predicates from trusted stdlib
runtime.loadSystemPredicates('stdlib/assign.glpc', {
  grantBodyKernelAccess: true  // Give access to internal registry
});

// User-loaded code does NOT get this access
runtime.loadUserCode('user/myprogram.glpc', {
  grantBodyKernelAccess: false  // No access to body kernels
});
```

### 7.2 Compiler Responsibilities

**For Guards**:
1. Parse arithmetic expressions: `X? + Y? > 10`
2. Generate guard kernel calls: `guard_add(X?, Y?, Temp)`
3. Wire up temporaries correctly

**For Bodies**:
1. Parse `:=` syntax
2. Generate system predicate call (or inline body kernel if optimizable)
3. Let system predicate handle safety

### 7.3 Error Reporting

**Guard Failure** (normal):
```
Goal suspended: waiting on variable X
Goal failed: trying next clause
```

**Body Kernel Abort** (error):
```
ABORT: Body kernel 'add' failed
Reason: Unbound reader X in add/3
Location: compute/3, clause 1, body goal 2
```

---

## 8. Examples

### 8.1 Factorial Using System Predicate

```glp
% Base case
factorial(0, 1).

% Recursive case - := handles all safety
factorial(N, F?) :-
  N? > 0 |                    % Guard predicate
  N1 := N? - 1,               % System predicate (safe)
  factorial(N1?, F1),
  F := N? * F1?.              % System predicate (safe)
```

### 8.2 Guard Arithmetic Compilation

**Source**:
```glp
test(X, Y, Z?) :- X? < Y? * 2 + 10 | Z = ok.
```

**Compiled**:
```
guard_mul(Y?, 2, Temp1)      % Guard kernel
guard_add(Temp1?, 10, Temp2) % Guard kernel
X? < Temp2?                  % Guard predicate
```

### 8.3 Safe Division

```glp
% System predicate := definition includes safe division
':='(Result, /(X?, Y?)) :-
  number(X?), number(Y?), Y? =\= 0 |
  div(X?, Y?, Result).        % Body kernel - safe to call

':='(Result, /(X?, Y?)) :-
  number(X?), number(Y?), Y? =:= 0 |
  abort("Division by zero").

% Fallback for non-ground operands
':='(Result, /(X?, Y?)) :-
  otherwise |
  X1 := X?,
  Y1 := Y?,
  Result := X1? / Y1?.
```

---

## 9. Future Extensions

### 9.1 User-Defined Body Kernels (FFI)

Allow users to define body kernels via FFI for performance:

```glp
% Declare external body kernel
:- extern body_kernel matrix_multiply(Matrix1, Matrix2, Result).

% Use in system predicate
matrix_mul(A, B, C?) :-
  matrix(A?), matrix(B?) |
  matrix_multiply(A?, B?, C).
```

### 9.2 Compiler Verification

Warn if body kernel preconditions not obviously met:

```glp
% Warning: no guard ensuring X is number
risky(X, Y?) :-
  true |
  Y := X? + 1.    % Compiler warning: "X? may not be numeric"
```

---

## 10. References

1. **FCP Ask/Tell Model**: Distinction between Ask (guards) and Tell (body) operations
2. **GLP SRSW Constraint**: Simplifies body kernel semantics (no unification conflicts)
3. **Warren Abstract Machine**: Inspiration for guard vs body execution phases

---

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-11-21 | Initial specification based on FCP analysis |

---

**End of Specification**
