%% distribute.glp - One-way stream distribute without ground guard
%% Distributes incrementally-constructed messages to two consumers
%% Suspends on unbound subterms until producer binds them

distribute([X|Xs], [Y?|Ys?], [Z?|Zs?]) :-
    copy(X?, Y, Z),
    distribute(Xs?, Ys, Zs).
distribute([], [], []).

copy(X, Y?, Z?) :- atom(X?) | Y = X?, Z = X?.
copy(X, Y?, Z?) :- number(X?) | Y = X?, Z = X?.
copy(X, Y?, Z?) :- tuple(X?) |
    X? =.. [F|Args],
    copy_functor(F?, F1, F2),
    copy_list(Args?, Args1, Args2),
    Y =.. [F1?|Args1?],
    Z =.. [F2?|Args2?].

%% Copy functor (always an atom)
copy_functor(F, F1?, F2?) :- atom(F?) | F1 = F?, F2 = F?.

copy_list([], [], []).
copy_list([H|T], [H1?|T1?], [H2?|T2?]) :-
    copy(H?, H1, H2),
    copy_list(T?, T1, T2).

%% Test 1: Simple ground messages
test_ground(Out1?, Out2?) :-
    distribute([a, b, c], Out1, Out2).

%% Test 2: Compound messages
test_compound(Out1?, Out2?) :-
    distribute([msg(hello, world), msg(foo, bar)], Out1, Out2).

%% Test 3: Nested compounds
test_nested(Out1?, Out2?) :-
    distribute([outer(inner(a, b), c)], Out1, Out2).
