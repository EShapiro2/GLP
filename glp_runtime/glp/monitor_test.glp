%% monitor_test.glp - Monitor test with two clients
%%
%% Two clients send requests to a shared monitor with timing.
%% Client 1 sends immediately; Client 2 waits 100ms before starting.
%% This demonstrates temporal coordination via wait guards.
%%
%% Expected results:
%%   V1 = 8 (client1 sees only its own: 5 + 3)
%%   V2 = 16 (client2 sees all: 5 + 10 + 3 - 2)
%%
%% Test goal:
%% test_monitor(V1, V2).

% Client 1: immediate - add 5, add 3, query value
client1(V1, [add(5), add(3), value(V1?)|Xs?]) :- client1_cont(Xs).
client1_cont([]).

% Client 2: delayed by 100ms - uses body list construction
client2(V, Ys?) :-
    wait(100) |
    Ys = [add(10), subtract(2), value(V?)|Ys1?],
    client2_cont(Ys1).
client2_cont([]).

% Test harness: merge client streams and feed to monitor
test_monitor(V1?, V2?) :-
    client1(V1, Xs),
    client2(V2, Ys),
    merge(Xs?, Ys?, Zs),
    monitor(Zs?).

% Monitor implementation (accumulator with add/subtract/value)
monitor(Reqs) :- monitor_loop(Reqs?, 0).

monitor_loop([add(N)|Reqs], Sum) :-
    Sum1 := Sum? + N?, monitor_loop(Reqs?, Sum1?).
monitor_loop([subtract(N)|Reqs], Sum) :-
    Sum1 := Sum? - N?, monitor_loop(Reqs?, Sum1?).
monitor_loop([value(V?)|Reqs], Sum) :-
    ground(Sum?) | V = Sum?, monitor_loop(Reqs?, Sum?).
monitor_loop([], _).

% Fair binary merge
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], Ys, Ys?).
merge(Xs, [], Xs?).
