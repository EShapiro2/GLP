%% GLP Module System Infrastructure
%% Implements FCP-style module system in pure GLP
%%
%% Core predicates:
%%   serve_import/3   - Bridge import stream to target module
%%   dispatcher/2     - Read from input channel, dispatch to reduce/2
%%   register_channel/3, lookup_channel/3 - Registry operations
%%   distribute/4, transmit/4 - RPC primitives

-module(modules).
-export([serve_import/3, dispatcher/2, register_channel/3, lookup_channel/3,
         distribute/4, transmit/4, activate_module/4]).

%% ============================================================
%% serve_import/3 - Bridge import stream to target module's input
%% ============================================================
%% serve_import(ImportStream?, ModuleName?, Registry?)
%%
%% Reads RPC messages from ImportStream and forwards them to
%% the target module's input channel (looked up in Registry).

serve_import([Msg|Rest], ModuleName, Registry) :-
    ground(Msg?), ground(ModuleName?), ground(Registry?) |
    lookup_and_send(ModuleName?, Registry?, Msg?),
    serve_import(Rest?, ModuleName?, Registry?).

serve_import([], _, _).

%% Helper: lookup channel and send message (combined to avoid SRSW violation)
lookup_and_send(ModuleName, Registry, Msg) :-
    lookup_channel_send(ModuleName?, Registry?, Msg?).

%% Combined lookup and send - writes message directly when channel found
%% Using helper to avoid compiler limitation with struct patterns in lists
lookup_channel_send(Name, [Entry|_], Msg) :-
    entry_matches_send(Entry?, Name?, Msg?).

lookup_channel_send(Name, [_|Rest], Msg) :-
    otherwise |
    lookup_channel_send(Name?, Rest?, Msg?).

%% Helper: check entry matches and write to channel
entry_matches_send(entry(N, Channel), Name, Msg) :-
    Name? =?= N? | write_msg(Channel?, Msg?).

%% Helper: write message to channel head
%% Msg binds to channel head (unbound), then Msg? receives value, binding the head
write_msg([Msg|_], Msg?).

%% ============================================================
%% dispatcher/2 - Process incoming RPC messages
%% ============================================================
%% dispatcher(InputChannel?, ModuleName?)
%%
%% Reads rpc(Goal, ResultVar) messages from InputChannel,
%% calls reduce/2 to get the body, then executes it.

dispatcher([rpc(Goal, ResultVar)|Rest], Module) :-
    ground(Goal?), ground(Module?) |
    dispatch_one(Module?, Goal?, ResultVar?),
    dispatcher(Rest?, Module?).

dispatcher([], _).

%% dispatch_one/3 - Handle a single RPC message
%% Note: reduce/2 is LOCAL to the module, not an RPC call
%% Module parameter kept for context (unused in basic case)
dispatch_one(_Module, Goal, ResultVar) :-
    reduce(Goal?, Body),
    run_body(Body?, ResultVar?).

%% run_body/2 - Execute a clause body
run_body(true, _).

run_body((A, B), R) :-
    known(A?), known(B?), ground(R?) |
    run_body(A?, R?),
    run_body(B?, R?).

run_body(Goal, _) :-
    otherwise |
    call(Goal?).

%% ============================================================
%% Registry Operations
%% ============================================================

%% register_channel/3 - Add module channel to registry
%% register_channel(Name?, Channel?, Registry)
%%
%% Registry is a stream of entry(Name, Channel) pairs.
%% Registration writes a new entry - pattern folded into head (unit clause).

register_channel(Name, Channel, [entry(Name?, Channel?)|_]).

%% lookup_channel/3 - Find module channel in registry
%% lookup_channel(Name?, Registry?, Channel)
%%
%% Searches registry for matching name, returns Channel.
%% Pattern folded into head: Ch? is returned directly.

lookup_channel(Name, [entry(N, Ch)|_], Ch?) :- Name? =?= N? | true.

lookup_channel(Name, [entry(_, _)|Rest], Channel) :-
    otherwise |
    lookup_channel(Name?, Rest?, Channel?).

%% ============================================================
%% RPC Primitives
%% ============================================================

%% distribute/4 - Static RPC via import vector
%% distribute(Index?, Goal?, ImportVec?, ResultVar)
%%
%% Writes rpc message to import stream at given index.
%% Uses helper to fold pattern into head.

distribute(Index, Goal, ImportVec, ResultVar) :-
    ground(Index?), ground(Goal?) |
    nth_write_rpc(Index?, ImportVec?, Goal?, ResultVar?).

%% nth_write_rpc - Get nth stream and write RPC message
%% Using helper to avoid compiler limitation with nested struct patterns
nth_write_rpc(1, [Stream|_], Goal, ResultVar) :-
    write_rpc(Stream?, Goal?, ResultVar?).

nth_write_rpc(N, [_|T], Goal, ResultVar) :-
    N? > 1 |
    N1 := N? - 1,
    nth_write_rpc(N1?, T?, Goal?, ResultVar?).

%% Helper: write rpc message to stream head
%% Msg binds to channel head, then passed as reader to build_rpc
write_rpc([Msg|_], Goal, ResultVar) :-
    build_rpc(Goal?, ResultVar?, Msg?).

%% Build rpc struct using unify - rpc(G?, R?) = Msg? binds Msg to struct
build_rpc(Goal, ResultVar, Msg) :-
    rpc(Goal?, ResultVar?) = Msg?.

%% transmit/4 - Dynamic RPC via registry lookup
%% transmit(ModuleName?, Goal?, Registry?, ResultVar)
%%
%% Looks up module in registry, sends RPC message.

transmit(ModuleName, Goal, Registry, ResultVar) :-
    ground(ModuleName?), ground(Goal?) |
    lookup_and_send_rpc(ModuleName?, Registry?, Goal?, ResultVar?).

%% Helper - combined lookup and RPC send
lookup_and_send_rpc(ModuleName, Registry, Goal, ResultVar) :-
    lookup_channel_rpc(ModuleName?, Registry?, Goal?, ResultVar?).

%% Combined lookup and RPC send
%% Using helper to avoid compiler limitation with struct patterns in lists
lookup_channel_rpc(Name, [Entry|_], Goal, ResultVar) :-
    entry_matches_rpc(Entry?, Name?, Goal?, ResultVar?).

lookup_channel_rpc(Name, [_|Rest], Goal, ResultVar) :-
    otherwise |
    lookup_channel_rpc(Name?, Rest?, Goal?, ResultVar?).

%% Helper: check entry matches and write RPC to channel
entry_matches_rpc(entry(N, Channel), Name, Goal, ResultVar) :-
    Name? =?= N? | write_rpc(Channel?, Goal?, ResultVar?).

%% ============================================================
%% Module Activation
%% ============================================================

%% activate_module/4 - Initialize a module
%% activate_module(ModuleName?, Imports?, InputChannel, Registry?)
%%
%% 1. Register this module's input channel
%% 2. Create import streams for each import
%% 3. Start serve_import for each import
%% 4. Start dispatcher on input channel

activate_module(Module, Imports, Input, Registry) :-
    ground(Module?), ground(Imports?), ground(Input?), ground(Registry?) |
    register_channel(Module?, Input?, Registry?),
    activate_imports(Imports?, Registry?, Module?, Input?).

%% activate_imports/4 - Set up imports and start dispatcher
activate_imports(Imports, Registry, Module, Input) :-
    ground(Imports?), ground(Registry?), ground(Module?), ground(Input?) |
    create_import_streams(Imports?, ImportVec),
    start_serve_imports(Imports?, ImportVec?, Registry?),
    dispatcher(Input?, Module?).

%% create_import_streams/2 - Create stream for each import
create_import_streams([], []).

create_import_streams([_|Rest], [_Stream|Streams]) :-
    create_import_streams(Rest?, Streams?).

%% start_serve_imports/3 - Start serve_import for each import
start_serve_imports([], [], _).

start_serve_imports([Imp|Imps], [Stream|Streams], Registry) :-
    ground(Registry?) |
    serve_import(Stream?, Imp?, Registry?),
    start_serve_imports(Imps?, Streams?, Registry?).

%% ============================================================
%% Utility Predicates
%% ============================================================

%% nth/3 - Get nth element (1-based indexing)
nth(1, [H|_], H?).

nth(N, List, Elem) :-
    N? > 1 |
    skip_and_find(N?, List?, Elem?).

%% Helper: decrement N, skip first element, recurse
skip_and_find(N, [_|T], Elem) :-
    N1 := N? - 1,
    nth(N1?, T?, Elem?).
