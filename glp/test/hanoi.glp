% hanoi.glp - Tower of Hanoi
%
% FUTURE TEST: Requires := arithmetic operator
% From Concurrent Prolog course (handout 2)

% ===== DIRECT EXECUTION =====

% hanoi(N, From, To, Moves) :- Moves to move N disks from From to To
hanoi(0, From, To, (From?, To?)).
hanoi(N, From, To, (Before?, (From?, To?), After?)) :-
  N? > 0, ground(From?), ground(To?) |
  N1 := N? - 1,
  free(From?, To?, Free),
  hanoi1(N1?, Free?, From?, To?, Before, After).

% Auxiliary to allow N1 and Free to be read multiple times
hanoi1(N1, Free, From, To, Before?, After?) :-
  ground(N1?), ground(Free?) |
  hanoi(N1?, From?, Free?, Before),
  hanoi(N1?, Free?, To?, After).

% free(A, B, C) :- C is the peg that is neither A nor B
free(a, b, c).
free(a, c, b).
free(b, a, c).
free(b, c, a).
free(c, a, b).
free(c, b, a).

% ===== METAINTERPRETER =====

run_hanoi(true).
run_hanoi((A, B)) :- run_hanoi(A?), run_hanoi(B?).
run_hanoi(A) :- otherwise | reduce_hanoi(A?, B), run_hanoi(B?).

% ===== REDUCE CLAUSES =====

% Base case: 0 disks
reduce_hanoi(hanoi(0, From, To, (From?, To?)), true).

% Recursive case: N > 0 disks
reduce_hanoi(hanoi(N, From, To, (Before?, (From?, To?), After?)),
       (N1 := N? - 1,
        free(From?, To?, Free),
        hanoi1(N1?, Free?, From?, To?, Before, After))) :-
  N? > 0, ground(From?), ground(To?) | true.

% Auxiliary reduction
reduce_hanoi(hanoi1(N1, Free, From, To, Before?, After?),
       (hanoi(N1?, From?, Free?, Before),
        hanoi(N1?, Free?, To?, After))) :-
  ground(N1?), ground(Free?) | true.

% free/3 facts reduce to true
reduce_hanoi(free(a, b, c), true).
reduce_hanoi(free(a, c, b), true).
reduce_hanoi(free(b, a, c), true).
reduce_hanoi(free(b, c, a), true).
reduce_hanoi(free(c, a, b), true).
reduce_hanoi(free(c, b, a), true).

% Handle := in metainterpreter
reduce_hanoi((X?:=T), true) :- X:=T?.

% ===== TESTS =====
% Direct: hanoi(2, a, c, Moves)
% Meta:   run_hanoi(hanoi(2, a, c, Moves))
% Should give moves to transfer 2 disks from peg a to peg c
