% monitor.glp - Monitor server with Alice and Bob clients
%
% Classic concurrent LP pattern: monitor maintains state (Sum),
% Alice and Bob cooperatively build a request stream.

% ======== MONITOR SERVER ========
monitor(Ops) :- mon(Ops?, 0).

mon([add(N)|Ops], Sum) :-
    Sum1 := Sum? + N?,
    mon(Ops?, Sum1?).

mon([subtract(N)|Ops], Sum) :-
    Sum1 := Sum? - N?,
    mon(Ops?, Sum1?).

% value(Sum?) reads Sum into pattern - caller's var unifies with it
mon([value(Sum?)|Ops], Sum) :-
    ground(Sum?) |
    mon(Ops?, Sum?).

mon([], _).

% ======== ALICE AND BOB ========
% Alice and Bob take turns sending operations to monitor

play(R?) :-
    alice(Ops, R),
    monitor(Ops?).

% Alice: add 10, add 5, pass stream tail to Bob
alice([add(10), add(5) | Tail?], R) :-
    bob(Tail, R?).

% Bob: subtract 3, query value, close stream
% R is writer (in value(R)), R? is reader (return value)
bob([subtract(3), value(R) | []], R?).

% ======== PLAY WITH WAIT ========
% Alice waits 50ms before passing stream to Bob
play_wait(R?) :-
    alice_wait(Ops, R),
    monitor(Ops?).

alice_wait([add(10), add(5) | Tail?], R) :-
    wait(50) |
    bob(Tail, R?).

% ======== PLAY WITH WAIT_UNTIL ========
% Only proceed if current time is past Sept 2001 (always true now)
play_wait_until(R?) :-
    wait_until(1000000000000) |
    alice(Ops, R),
    monitor(Ops?).
