%%%%% Leonudi Book, Chapter 8, pp 125-137 %%%%%

\input wizzle
\input ludbumac
\hsize 12.4truecm
\vsize 18.2truecm
\input headline
\tolerance 3000
\chapnum=0\advance\chapnum by 7
\numberfirst
\startpage{125}

\chapa{Arithmetic}
The logic programs for performing arithmetic presented in Section~3.1 are
very elegant, but they are not practical. Any reasonable computer
provides very efficient arithmetic operations directly in hardware, and
practical logic programming languages cannot afford to ignore this
feature. Computations such as addition take unit time on most computers
independent of the size of the addends (as long as they are smaller than
some large constant). The recursive logic program for {\tt plus} (Program
\Proadditi) takes time proportional to the first of the numbers being
added.  This could be improved by switching to binary or decimal
notation but still won't compete with direct execution by dedicated
hardware.\par
Every Prolog implementation reserves some predicate names for
system-related procedures. Queries to these predicates, called {\it
system predicates\/}, are handled by special code in the implementation
in contrast to calls to predicates defined by pure Prolog programs. A
Prolog implementor should build system predicates that complement pure
Prolog naturally and elegantly. Other names for system predicates
are {\it evaluable\/} predicates, {\it builtin\/} predicates, or {\it
bips\/}, the latter two being referred to in the draft for Standard
Prolog.\par
\sect{System Predicates for Arithmetic}
The role of the system predicates for arithmetic introduced in Prolog is
to provide an interface to the underlying arithmetic capabilities of the
computer in a straightforward way. The price paid for this efficiency is
that some of the machine-oriented arithmetic operations are not as
general as their logical counterparts. The interface provided is an
arithmetic evaluator, which uses the underlying arithmetic facilities
of the computer. Standard Prolog has a system predicate {\tt
is(Value,Expression)} for arithmetic evaluation. Goals with the predicate
{\tt is} are usually written in binary infix form, taking advantage of
the operator facility of Prolog, about which we now digress.\par
Operators are used in order to make programs more readable. People are
very flexible and learn to adjust to strange surroundings --- they can
become accustomed to reading Lisp and Fortran programs, for example. We
believe nonetheless that syntax is important; the power of a good
notation is well known from mathematics. An integral part of a good
syntax for Prolog is the ability to specify and use operators.\par
Operators, for example $\ne$ and $<$, have already been used in earlier
chapters. Standard Prolog provides several operators, which we introduce
as they arise. Programmers can also define their own operators using the
built-in predicate {\tt op/3}. An explanation of the mechanism for
operator declarations, together with a list of pre-defined operators and
their precedences is given in Appendix~B.\par
Queries using the arithmetic evaluator provided by Prolog have the
form {\tt Value is Expression?}. Queries to the evaluator are interpreted
as follows. The arithmetic expression {\tt Expression} is evaluated and
the result is unified with {\tt Value}. Once arithmetic evaluation
succeeds, the query succeeds or fails depending on whether unification
succeeds or fails.\par
Here are some examples of simple addition, illustrating the use and
behavior of the evaluator. The query {\tt (X is 3+5)?} has the solution
{\tt X=8}. This is the standard use of the evaluator, instantiating a
variable to the value of an arithmetic expression. The query {\tt (8 is
3+5)?} succeeds. Having both arguments to {\tt is} instantiated allows
checking the value of an arithmetic expression. {\tt (3+5 is 3+5)?}
fails because the left-hand argument, {\tt 3+5}, does not unify with {\tt
8}, the result of evaluating the expression.\par
Standard Prolog specifies a range of arithmetic operations that should be
supported by Prolog for both integers and reals represented as
floating-point numbers. In particular, the evaluator provides for
addition, subtraction, multiplication, and division ($+,-,\ast,/$) with
their usual mathematical precedences. In this book, we restrict
ourselves to integer arithmetic.\par What happens if the term to be
evaluated is not a valid arithmetic expression? An expression can be
invalid for one of two reasons, which should be treated differently,
at least conceptually. A term such as {\tt 3+x} for a constant {\tt x}
cannot be evaluated. In contrast, a term {\tt 3+Y} for a variable {\tt
Y} may or may not be evaluable, depending on the value of {\tt Y}.\par
The semantics of any logic program is completely defined, and, in this
sense, logic programs cannot have runtime ``errors." For example, the
goal {\tt X is 3+Y} has solutions $\{${\tt X=3,Y=0}$\}$. However, when
interfacing logic programs to a computer, the limitations of the
machine should be taken into account. A runtime error occurs when the
machine cannot determine the result of the computation because of
insufficient information, that is, uninstantiated variables. This is
distinct from goals that simply fail. Extensions to Prolog and other
logic languages handle such ``errors" by suspending until the values
of the concerned variables are known. The execution model of Prolog as
introduced does not permit suspension. Instead of simply failure, we
say an error condition occurs.\par The query {\tt (X is 3+x)?} fails
because the right-hand argument cannot be evaluated as an arithmetic
expression. The query {\tt (X is 3+Y)?} is an example of a query that
would succeed if {\tt Y} were instantiated to an arithmetic
expression. Here an error condition should be reported.\par A common
misconception of beginning Prolog programmers is to regard {\tt is} as
taking the place of assignment as in conventional programming
languages. It is tempting to write a goal such as {\tt (N is N+1)}. This
is meaningless. The goal fails if {\tt N} is instantiated, or causes an
error if {\tt N} is a variable.\par
Further system predicates for arithmetic are the comparison operators.
Instead of the logically defined $<$, $\le$ (written $=<$), $>$, $\ge$
(written $>=$), Prolog directly calls the underlying arithmetic
operations. We describe the behavior of {\tt $<$}; the others are
virtually identical. To answer the query {\tt (A $<$ B)?}, {\tt A} and
{\tt B} are evaluated as arithmetic expressions. The two resultant
numbers are compared, and the goal succeeds if the result of evaluating
{\tt A} is less than the result of evaluating {\tt B}. Again, if {\tt A}
or {\tt B} is not an arithmetic expression, the goal will fail, and an
error condition should result if {\tt A} or {\tt B} are not ground.\par
Here are some simple examples. The query {\tt (1 $<$ 2)?} succeeds, as
does the query {\tt (3-2 $<$ 2$\ast$3+1)?}. On the other hand, {\tt (2 $<$
1)?} fails, and {\tt (N $<$ 1)?} generates an error when {\tt N} is a
variable.\par
Tests for equality and inequality of values of arithmetic expressions are
implemented via the builtin predicates {\tt $=:=$} and {\tt $=\hskip -2pt
/\hskip -2pt=$}, which evaluate both of their arguments and compare the
resulting values.\par
\sect{Arithmetic Logic Programs Revisited}
Performing arithmetic via evaluation rather than logic demands a
reconsideration of the logic programs for arithmetic presented in
Section~3.1. Calculations can certainly be done more efficiently. For
example, finding the minimum of two numbers can use the underlying
arithmetic comparison. The program syntactically need not change from
Program~\Promintwonum. Similarly, the greatest common divisor of two
integers can be computed efficiently using the usual Euclidean
algorithm, given as Program~\Procomgrecom. Note that the explicit
condition {\tt J $>$ 0} is necessary to avoid multiple solutions when
{\tt J} equals {\tt 0} and errors from calling {\tt mod} with a zero
argument. 
\midinsert
\halign{\hskip 34pt\lft{\tt #}\cr
{\it greatest\_common\_divisor\/}({\it X,Y,Z\/}) $\lar$\cr
\qi {\it Z\/} {\rm is the greatest common divisor of the integers} {\it
X\/} {\rm and} {\it Y\/}{\rm .}\cr
\noalign{\medskip}
greatest\_common\_divisor(I,0,I).\cr
greatest\_common\_divisor(I,J,Gcd) $\lar$\cr
\qi J $>$ 0, R is I mod J, greatest\_common\_divisor(J,R,Gcd).\cr
\noalign{\bigskip}
{\bf Program \Procomgrecom}{\rm :~~Computing the greatest common divisor
of two integers}\cr}
\endinsert\par
Two features of logic programs for arithmetic are missing from their
Prolog counterparts. First, multiple uses of programs are restricted.
Suppose we wanted a predicate {\tt plus(X,Y,Z)} that performed as before,
built using {\tt is}. The obvious definition is\medskip
\halign{\hskip 40pt\lft{\tt #}\cr
plus(X,Y,Z) $\lar$ Z is X+Y.\cr}\medno
This works correctly if {\tt X} and {\tt Y} are instantiated to integers.
However, we cannot use the same program for subtraction with a goal such
as {\tt plus(3,X,8)?}, which raises an error condition. Meta-logical
tests are needed if the same program is to be used for both addition and
subtraction. We defer this until meta-logical predicates are introduced
in Chapter~10.\par
Programs effectively become specialized for a single use, and it is
tricky to understand what happens when the program is used differently.
Program~\Promintwonum\ for {\tt minimum}, for example, can be used
reliably only for finding the minimum of two integers.\par
The other feature missing from Prolog programs for arithmetic is the
recursive structure of numbers. In logic programs, the structure is used
to determine which rule applies, and to guarantee termination of
computations. Program~\Procomfacnum\ is a Prolog program for computing
factorials closely corresponding to Program~\Procomfac. The recursive
rule is more clumsy than before. The first argument in the recursive call
of {\tt factorial} must be calculated explicitly rather than emerging as
a result of unification. Furthermore, the explicit condition determining
the applicability of the recursive rule, {\tt N $>$ 0}, must be given.
This is to prevent nonterminating computations with goals such as {\tt
factorial(-1,N)?} or even {\tt factorial(3,F)?}. Previously, in the logic
program, unification with the recursive structure prevented
nonterminating computations.
\topin
\halign{\hskip 40pt\lft{\tt #}\cr
{\it factorial\/}({\it N,F\/}) $\lar$\cr
\qi {\it F\/} {\rm is the integer} {\it N\/} {\rm factorial.}\cr
\noalign{\medskip}
factorial(N,F) $\lar$\cr
\qi N $>$ 0, N1 is N-1, factorial(N1,F1), F is N$\ast$F1.\cr
factorial(0,1).\cr
\noalign{\bigskip}
{\bf Program \Procomfacnum}{\rm :~~Computing the factorial of a
number}\cr}
\endin\par
Program~\Procomfacnum\ corresponds to the standard recursive definition
of the factorial function. Unlike Program~\Procomfac, the program can be
used only to calculate the factorial of a given number. A {\tt factorial}
query where the first argument is a variable will cause an error
condition.\par
We must modify the concept of correctness of a Prolog program to
accommodate behavior with respect to arithmetic tests. Other system
predicates that generate runtime ``errors" are handled similarly. A
Prolog program is {\it totally correct\/} over a domain {\it D\/} of
goals if for all goals in {\it D\/} the computation terminates, does not
produce a runtime error, and has the correct meaning. Program
\Procomfacnum\ is totally correct over the domain of goals where the
first argument is an integer.\vskip 15pt\parno
{\bf Exercises for Section 8.2}\vskip 5pt\par
\offset{20pt}{(i)} The {\it N\/}th triangular number is the sum of
the numbers up to and including {\it N\/}. Write a program for the
relation {\tt triangle(N,T)}, where {\tt T} is the {\tt N}th
triangular number. (Hint:~~Adapt Program~\Procomfacnum.)\par
\offset{20pt}{(ii)} Write a Prolog program for {\tt power(X,N,V)}, where
{\tt V} equals {\tt X}$^N$. Which way can it be used?
(Hint:~~Model it on Program~\Proexprepmul\ for {\tt exp}.)\par
\offset{20pt}{(iii)} Write Prolog programs for other logic programs for
arithmetic given in the text and exercises in Section~3.1.\par
\offset{20pt}{(iv)} Write a Prolog program to generate a Huffman encoding
tree from a list of symbols and their relative frequencies.\par
\sect{Transforming recursion into iteration}
In Prolog there are no iterative constructs as such, and a more general
concept, namely recursion, is used to specify both recursive and
iterative algorithms. The main advantage of iteration over recursion is
efficiency, mostly space efficiency. In the implementation of
recursion, a data structure (called a stack frame) has to be maintained
for every recursive call that has not terminated yet. A recursive
computation involving {\it n\/} recursive procedure calls would require,
therefore, space linear in {\it n\/}. On the other hand, an iterative
program typically uses only a constant amount of memory, independent of
the number of iterations.\par
Nevertheless, there is a restricted class of recursive programs that
corresponds quite closely to conventional iterative programs. Under some
conditions, explained further in Section~11.2 on tail recursion
optimization, such Prolog programs can be implemented with almost the
same efficiency as iterative programs in conventional languages. For this
reason, it is preferable to express a relation using an iterative
program, if possible. In this section, we show how recursive programs can
be made iterative using accumulators.\par
Recall that a pure Prolog clause is {\it iterative\/} if it has one
recursive call in the body. We extend this notion to full Prolog, and
allow zero or more calls to Prolog system predicates {\it before\/} the
recursive call. A Prolog procedure is {\it iterative\/} if it contains
only unit clauses and iterative clauses.\par
Most simple arithmetic calculations can be implemented by iterative
programs.\par
Factorials can be computed, for example, in a loop where the numbers up
to the desired factorial are multiplied together. A procedure in a
Pascal-like language using a {\it while} loop is given in Figure~\Figcomfacite.
Its iterative behavior can be encoded directly in Prolog with an
iterative program.
\midinsert\vskip -0.2truecm
$$\vcenter{\halign{\lft{#}\cr
factorial(N);\cr
\qi I is 0; T is 1;\cr
\qi {\it while} I $<$ N {\it do}\cr
\qii I is I + 1; T is T  $\ast$ I  end;\cr
\qi return T.\cr}}$$\medskip
\ctrline{{\bf  Figure \Figcomfacite}:~~Computing factorials iteratively}
\endinsert\par
Prolog does not have storage variables, which can hold  intermediate
results of the computation and be modified as the computation
progresses. Therefore, to implement iterative algorithms, which require
the storage of intermediate results, Prolog procedures are augmented with
additional arguments, called {\it accumulators\/}. Typically, one of the
intermediate values constitutes the result of the computation upon
termination of the iteration. This value is unified with the result
variable using the unit clause of the procedure.\par
This technique is demonstrated by Program~\Proitefac, which is a Prolog
definition of {\tt factorial} that mirrors the behavior of the {\it
while} loop in Figure~\Figcomfacite. It uses {\tt factorial(I,N,T,F)},
which is true if {\tt F} is the value of {\tt N} factorial, and {\tt
I} and {\tt T} are the values of the corresponding loop variables
before the ({\tt I}+1)th iteration of the loop.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it factorial\/}({\it N,F\/}) $\lar$\cr
\qi {\it F\/} {\rm is the integer} {\it N\/} {\rm factorial.}\cr
\noalign{\medskip}
factorial(N,F) $\lar$ factorial(0,N,1,F).\cr
\noalign{\vskip 5pt}
factorial(I,N,T,F) $\lar$\cr
\qi I $<$ N, I1 is I+1, T1 is T$\ast$I1, factorial(I1,N,T1,F).\cr
factorial(N,N,F,F).\cr
\noalign{\bigskip}
{\bf  Program \Proitefac}{\rm :~~An iterative} factorial\cr}
\endinsert\par
The basic iterative loop is performed by the iterative procedure {\tt
factorial/4}. Each reduction of a goal using {\tt factorial/4}
corresponds to an iteration of the {\it while} loop. The call of {\tt
factorial/4} by {\tt factorial/2} corresponds to the initialization
stage. The first argument of {\tt factorial/4}, the loop counter, is set
to 0.\par
The third argument of {\tt factorial/4} is used as an accumulator of the
running value of the product. It is initialized to 1 in the
call to {\tt factorial/4} by {\tt factorial/2}. The handling of both
accumulators in Program~\Proitefac\ is a typical programming technique in
Prolog. It is closely related  to the use of accumulators in Programs
\Prorevlis b and \Prorevwnodup\ for collecting elements in a list.\par
Accumulators are logical variables rather than locations in memory. The
value is passed between iterations, not an address. Since logical
variables are ``write-once," the updated value, a new logical variable,
is passed each time. Stylistically, we use variable names with the
suffix {\tt 1}, for example, {\tt T1} and {\tt I1}, to indicate updated
values.\par
The computation terminates when the counter {\tt I} equals {\tt N}. The
rule for {\tt factorial/4} in Program~\Proitefac\ no longer applies, and
the fact succeeds. With this successful reduction, the value of the
factorial is returned. This happens as a result of the unification
with the accumulator in the base clause. Note that the logical variable
representing the solution, the final argument of {\tt factorial/4}, had
to be carried throughout the whole computation to be set on the final
call of {\tt factorial}. This passing of values in arguments is characteristic
of Prolog programs and might seem strange to the newcomer.\par
Program \Proitefac\ exactly mirrors the {\it while} loop for factorial
given in Figure~\Figcomfacite. Another iterative version of {\tt
factorial} can be written by counting down from {\tt N} to 0, rather
than up from 0 to {\tt N}. The basic program structure remains the
same and is given as Program~\Proanoitefac. There is an initialization
call that sets the value of the accumulator, and recursive and base
clauses implementing the {\it while} loop.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it factorial\/}({\it N,F\/}) $\lar$\cr
\qi {\it F\/} {\rm is the integer} {\it N\/} {\rm factorial.}\cr
\noalign{\medskip}
factorial(N,F) $\lar$ factorial(N,1,F).\cr
\noalign{\vskip 5pt}
factorial(N,T,F) $\lar$\cr
\qi N $>$ 0, T1 is T$\ast$N, N1 is N-1, factorial(N1,T1,F).\cr
factorial(0,F,F).\cr
\noalign{\bigskip}
{\bf Program \Proanoitefac}{\rm :~~Another iterative} factorial\cr}
\vskip 0.6truecm
\halign{\hskip 40pt\lft{\tt #}\cr
{\it between\/}({\it I,J,K\/}) $\lar$\cr
\qi {\it K\/} {\rm is an integer between the integers} {\it I\/} {\rm
and} {\it J\/} {\rm inclusive.}\cr
\noalign{\medskip}
between(I,J,I) $\lar$ I $\le$ J.\cr
between(I,J,K) $\lar$ I $<$ J, I1 is I+1, between(I1,J,K).\cr
\noalign{\bigskip}
{\bf  Program \Progenranint}{\rm :~~Generating a range of integers}\cr}
\endinsert\par
Program~\Proanoitefac\ is marginally more efficient than Program
\Proitefac. In general, the fewer arguments a procedure has, the more
readable it becomes, and the faster it runs.\par
A useful iterative predicate is {\tt between(I,J,K)}, which is true if
{\tt K} is an integer between {\tt I} and {\tt J} inclusive. It can be
used to generate nondeterministically integer values within a range
(see Program~8.5). This is useful in generate-and-test programs,
explained in Section~14.1, and in failure-driven loops, explained in
Section~12.5.\par 
Iterative programs can be written for calculations over lists of integers
as well.  Consider the relation {\tt sumlist(IntegerList,Sum)}, where {\tt
Sum} is the sum of the integers in the list {\tt IntegerList}. We present
two programs for the relation. Program~\Prosumlisint\ is a recursive
formulation. To sum a list of integers, sum the tail, and then add the
head. Program~\Proiteversum\ uses an accumulator to compute the
progressive sum precisely as Program~\Proitefac\ for {\tt factorial} uses
an accumulator to compute a progressive product. An auxiliary predicate,
{\tt sumlist/3}, is introduced with an extra argument for the accumulator,
whose starting value, 0, is set in the initial call to {\tt
sumlist/3}. The sum is passed out in the final call by unification with
the base fact. The only difference between Program~\Proiteversum\ and the
iterative versions of {\tt factorial} is that the recursive structure of
the list rather than a counter is used to control the iteration.
\topin
\halign{\hskip 40pt\lft{\tt #}\cr
{\it sumlist\/}({\it Is,Sum\/}) $\lar$\cr
\qi {\it Sum\/} {\rm is the sum of the list of integers} {\it Is\/}{\rm .}\cr
\noalign{\medskip}
sumlist(\(I$\mid$Is\),Sum) $\lar$ sumlist(Is,IsSum), Sum is I+IsSum.\cr
sumlist(\(~\),0).\cr
\noalign{\bigskip}
{\bf  Program \Prosumlisint}{\rm :~~Summing a list of integers}\cr}
\vskip 0.6truecm
\halign{\hskip 40pt\lft{\tt #}\cr
{\it sumlist\/}({\it Is,Sum\/}) $\lar$\cr
\qi {\it Sum\/} {\rm is the sum of the list of integers} {\it
Is\/}{\rm .}\cr
\noalign{\medskip}
sumlist(Is,Sum) $\lar$ sumlist(Is,0,Sum).\cr
\noalign{\vskip 5pt}
sumlist(\(I$\mid$Is\),Temp,Sum) $\lar$\cr
\qi Temp1 is Temp+I, sumlist(Is,Temp1,Sum).\cr
sumlist(\(~\),Sum,Sum).\cr}\bigskip
\halign{\hskip 40pt\lft{#}~~&\lft{#}\cr
{\bf Program \Proiteversum}:&Iterative version of summing a list\cr
&of integers using an accumulator\cr}
\endin\par
Let us consider another example. The inner product of two vectors {\it
X$_i$,Y$_i$\/} is the sum $X_1\cdot Y_1 + \cdots + X_n\cdot Y_n$. If we
represent vectors as lists, it is straightforward to write a program
for the relation {\tt inner\_product(Xs,Ys,IP)}, where 
{\tt IP} is the inner product of {\tt Xs} and {\tt Ys}. Programs
\Procominnpro\ and \Procominnvec\ are recursive and iterative versions,
respectively. The iterative version of {\tt inner\_product} bears the
same relation to the recursive {\tt inner\_product} that Program
\Proiteversum\ for {\tt sumlist} bears to Program~\Prosumlisint.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it inner\_product\/}({\it Xs,Ys,Value\/}) $\lar$\cr
\qi {\it Value\/} {\rm is the inner product of the vectors}\cr
\qi {\rm represented by the lists of integers} {\it Xs\/} {\rm and} {\it
Ys\/}{\rm .}\cr
\noalign{\medskip}
inner\_product(\(X$\mid$Xs\),\(Y$\mid$Ys\),IP) $\lar$\cr
\qi inner\_product(Xs,Ys,IP1), IP is X$\ast$Y+IP1.\cr
inner\_product(\(~\),\(~\),0).\cr
\noalign{\bigskip}
{\bf  Program \Procominnpro}{\rm :~~Computing inner products of
vectors}\cr}
\endinsert\par
\topin
\halign{\hskip 40pt\lft{\tt #}\cr
{\it inner\_product\/}({\it Xs,Ys,Value\/}) $\lar$\cr
\qi {\it Value\/} {\rm is the inner product of the vectors}\cr
\qi {\rm represented by the lists of integers} {\it Xs\/} {\rm and} {\it
Ys\/}{\rm .}\cr
\noalign{\medskip}
inner\_product(Xs,Ys,IP) $\lar$ inner\_product(Xs,Ys,0,IP).\cr
\noalign{\vskip 5pt}
inner\_product(\(X$\mid$Xs\),
\(Y$\mid$Ys\),Temp,IP) $\lar$\cr
\qi Temp1 is X$\ast$Y+Temp, inner\_product(Xs,Ys,Temp1,IP).\cr
inner\_product(\(~\),\(~\),IP,IP).\cr
\noalign{\bigskip}
{\bf  Program \Procominnvec}{\rm :~~Computing inner products of vectors
iteratively}\cr}
\endin\par
Both Programs \Procominnpro\ and \Procominnvec\ are correct for goals
{\tt inner\_product(Xs,Ys,Zs)}, where {\tt Xs} and {\tt Ys} are lists of
integers of the same length. There is a built-in check that the vectors
are of the same length. The programs fail if {\tt Xs} and {\tt Ys} are of
different lengths.\par
The similarity of the relations between Programs \Prosumlisint\ and
\Proiteversum, and Programs \Procominnpro\ and \Procominnvec,
suggests that one may be automatically transformed to the other. The
transformation of recursive programs to equivalent iterative programs is
an interesting research question. Certainly it can be done for the simple
examples shown here.\par
The sophistication of a Prolog program depends on the underlying logical
relation it axiomatizes. Here is a very elegant example of a simple
Prolog program solving a complicated problem.\par
Consider the following problem: Given a closed planar polygon chain {\it
$\{$P$_1$,P$_2$,$\ldots$,P$_n$$\}$}, compute the area of the enclosed
polygon and the orientation of the chain. The area is computed by the
line integral\medskip
\halign{\hskip 40pt\lft{#}\cr
1/2 $\int$xdy--ydx,\cr}\medno
where the integral is over the polygon chain.\par
The solution is given in Program~\Procomarepol, which defines the
relation {\tt area(Chain,Area)}. {\tt Chain} is given as a list of
tuples, for example, \($(4,6),(4,2),(0,8),(4,6)$\). The magnitude of
{\tt Area} is the area of the polygon bounded by the chain. The sign
of {\tt Area} is positive if the orientation of the polygon is
counterclockwise, and negative if it is clockwise. 
\topin
\halign{\hskip 40pt\lft{\tt #}\cr
{\it area\/}({\it Chain,Area\/}) $\lar$\cr
\qi {\it Area\/} {\rm is the area of the polygon enclosed by the list of
points}\cr
\qi {\it Chain\/}{\rm , where the coordinates of each point are
represented by}\cr
\qi {\rm a pair} ({\it X,Y}) {\rm of integers.}\cr
\noalign{\medskip}
area(\(Tuple\),0).\cr
area(\((X1,Y1),(X2,Y2)$\mid$XYs\),Area) $\lar$\cr
\qi area(\((X2,Y2)$\mid$XYs\),Area1),\cr
\qi Area is (X1$\ast$Y2-Y1$\ast$X2)/2 + Area1.\cr
\noalign{\bigskip}
{\bf  Program \Procomarepol}{\rm :~~Computing the area of polygons}\cr}
\endin\par
The query {\tt area(\((4,6),(4,2),(0,8),(4,6)\),Area)?} has the solution
{\tt Area = -8}. The polygon gains opposite orientation by reversing the
order of the tuples. The solution of the query {\tt
area(\((4,6),(0,8),(4,2),(4,6)\),Area)?} is {\tt Area = 8}.\par
The program shown is not iterative. Converting it to be iterative is the
subject of Exercise~(v) at the end of the section.\par
An iterative program can be written to find the maximum of a list of
integers. The relation scheme is {\tt maxlist(Xs,Max)}, and the program
is given as Program~\Profinmaxlis. An auxiliary predicate {\tt
maxlist(Xs,X,Max)} is used for the relation that {\tt Max} is the maximum
of {\tt X} and the elements in the list {\tt Xs}. The second argument of
{\tt maxlist/3} is initialized to be the first element of the list. Note
that the maximum of an empty list is not defined by this program.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it maximum}({\it Xs,N\/}) $\lar$\cr
\qi {\it N\/} {\rm is the maximum of the list of integers} {\it
Xs\/}{\rm .}\cr
\noalign{\medskip}
maxlist([X$\mid$Xs],M) $\lar$ maxlist(Xs,X,M).\cr
\noalign{\vskip 5pt}
maxlist([X$\mid$Xs],Y,M) $\lar$ maximum(X,Y,Y1), maxlist(Xs,Y1,M).\cr
maxlist([~],M,M).\cr
\noalign{\vskip 5pt}
maximum(X,Y,Y) $\lar$ X $\le$ Y.\cr
maximum(X,Y,X) $\lar$ X $>$ Y. \cr
\noalign{\bigskip}
{\bf Program \Profinmaxlis}{\rm :~~Finding the maximum of a list of
integers}\cr}
\endinsert\par
The standard recursive program for finding the maximum of a list of
integers constitutes a slightly different algorithm. The recursive
formulation finds the maximum of the tail of the list and compares it to
the head of the list to find the maximum element. In contrast, 
Program~\Profinmaxlis\ keeps track of the running maximum as the list
is traversed.\par
Program~\Prodetlenlis\ for finding the length of a list is interesting,
affording several ways of translating a logic program into Prolog, each
of which has its separate features. One possibility is Program
\Prochelenlis, which is iterative. Queries {\tt length(Xs,N)?} are
handled correctly if {\tt N} is a natural number, testing if the
length of a list is {\tt N}, generating a list of {\tt N} uninstantiated
elements, or failing. The program is unsuitable, however, for finding the
length of a list with a call such as {\tt length(\(1,2,3\),N)?}. This
query generates an error.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it length\/}({\it Xs,N\/}) $\lar$\cr
\qi {\it Xs\/} {\rm is a list of length} {\it N\/}{\rm .}\cr
\noalign{\medskip}
length(\(X$\mid$Xs\),N)
$\lar$ N $>$ 0, N1 is N-1, length(Xs,N1).\cr
length(\(~\),0).\cr
\noalign{\bigskip}
{\bf  Program \Prochelenlis}{\rm :~~Checking the length of a list}\cr}
\endinsert\par
The length of a list can be found using Program~\Profinlenlis.
This program cannot be used, however, to generate a list of {\tt N}
elements. In contrast to Program~\Prochelenlis, the computation does not
terminate if the first argument is an incomplete list. Different programs
for {\tt length} are needed for the different uses.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it length\/}({\it Xs,N\/}) $\lar$\cr
\qi {\it N\/} {\rm is the length of the list} {\it Xs\/}{\rm .}\cr
\noalign{\medskip}
length(\(X$\mid$Xs\),N) $\lar$ length(Xs,N1), N is N1+1.\cr
length(\(~\),0).\cr
\noalign{\bigskip}
{\bf  Program \Profinlenlis}{\rm :~~Finding the length of a list}\cr}
\endinsert\par
Similar considerations about the intended use of a program occur when
trying to define the relation {\tt range(M,N,Ns)}, where {\tt Ns} is
the list of integers between {\tt M} and {\tt N} inclusive. Program
\Progenlisint\ has a specific use: generating a list of numbers in a
desired range. The program is totally correct over all goals {\tt
range(M,N,Ns)} where {\tt M} and {\tt N} are instantiated. The program
cannot be used, however, to find the upper and lower limits of a range of
integers, because of the test {\tt M $<$ N}. Removing this test would allow
the program to answer a query {\tt range(M,N,\(1,2,3\))?}, but then it
would not terminate for the intended use, solving queries such as {\tt
range(1,3,Ns)?}.
\midinsert
\halign{\hskip 40pt\lft{\tt #}\cr
{\it range\/}({\it M,N,Ns\/}) $\lar$\cr
\qi {\it Ns\/} {\rm is the list of integers between} {\it M\/} {\rm and}
{\it N\/} {\rm inclusive.}\cr
\noalign{\medskip}
range(M,N,\(M$\mid$Ns\)) $\lar$ M $<$ N, M1 is M+1, range(M1,N,Ns).\cr
range(N,N,\(N\)).\cr
\noalign{\bigskip}
{\bf  Program \Progenlisint}{\rm :~~Generating a list of integers in a
given range}\cr}
\endinsert\vskip 15pt \parno
{\bf Exercises for Section 8.3}\vskip 5pt \par
\offset{25pt}{(i)} Write an iterative version for {\tt triangle(N,T)},
posed as Exercise~8.2(i).\par
\offset{25pt}{(ii)} Write an iterative version for {\tt power(X,N,V)},
posed as Exercise~8.2(ii).\par
\offset{25pt}{(iii)} Rewrite Program~\Progenranint\ so that the
successive integers are generated in descending order.\par
\offset{25pt}{(iv)} Write an iterative program for the relation {\tt
timeslist(IntegerList,Pro-}\linebreak
{\tt duct)} computing the product of a list of integers, analogous to
Program~\Proiteversum\ for {\tt sumlist}.\par
\offset{25pt}{(v)} Rewrite Program~\Procomarepol\ for finding the area
enclosed by a polygon so that it is iterative.\par
\offset{25pt}{(vi)} Write a program to find the minimum of a list of
integers.\par
\offset{25pt}{(vii)} Rewrite Program~\Profinlenlis\ for finding the
length of a list so that it is iterative.
(Hint:~~Use a counter, as in Program \Proitefac.)\par
\offset{25pt}{(viii)} Rewrite Program \Progenlisint\ so that the range of
integers is built bottom-up rather than top-down.\par
\sect{Background}
The examples given in this chapter are small and do not especially
exploit Prolog's features. Algorithms that are fundamentally recursive
are more interesting in Prolog. A good example of such a program is the
Fast Fourier Transform, for which efficient versions have been written
in Prolog.\par
A good place for reading about Huffman encoding trees for Exercise
8.2(iv) is Abelson and Sussman (1985).\par
A program for transforming recursive programs to iterative ones, which
handles the examples in the text, is described in Bloch (1984).\par
Program~\Procomarepol, computing the area of a polygon, was shown to us
by Martin Nilsson.\par\bye

