



                                                Chapter  15



            Incomplete  Data  Structures



    The programs presented so far have been discussed in terms of relations


between complete data structures. Powerful programming techniques emerge from


extending the discussion to incomplete data structures, as demonstrated in this


chapter.


    The first section discusses difference-lists, an alternative data structure*
 * to


lists for representing a sequence of elements. They can be used to simplify and*
 * in-


crease the efficiency of list-processing programs. In some respects, difference*
 *-lists


generalize the concept of accumulators.  Data structures built from the differ-


ence of incomplete structures other than lists are discussed in the second sect*
 *ion.


The third section shows how tables and dictionaries, represented as incomplete


structures, can be built incrementally during a computation.  The final section


discusses queues, an application of difference-lists.



15.1   Difference-Lists




15.1                                              Difference-Lists247



    Consider the sequence of elements 1,2,3. It can be represented as the diffe*
 *r-


ence between pairs of lists.  It is the difference between the lists [1,2,3,4,5*
 *] and


[4,5], the difference between the lists [1,2,3,8] and [8], and the difference b*
 *etween


[1,2,3] and [ ]. Each of these cases is an instance of the difference between t*
 *wo


incomplete lists [1,2,3jXs] and Xs.


    We denote the difference between two lists as a structure AsnBs, which is


called a difference-list. As is the head of the difference-list and Bs the tail*
 *. In this


example [1,2,3jXs]nXs is the most general difference-list representing the sequ*
 *ence


1,2,3, where [1,2,3jXs] is the head of the difference-list and Xs the tail.


    Logical expressions are unified, not evaluated. Consequently the binary fun*
 *c-


tor used to denote difference-lists can be arbitrary. Of course, the user must *
 *be


consistent in using the same functor in any one program. Another common choice


of functor besides n is {. The functor for difference-lists can also be omitted*
 * en-


tirely, the head and the tail of the difference-list becoming separate argument*
 *s in


a predicate. While this last choice has advantages from a perspective of effici*
 *ency,


we use the functor n throughout for clarity.


    Lists and difference-lists are closely related. Both are used to represent *
 *se-


quences of elements.  Any list L can be trivially represented as a difference-l*
 *ist


Ln[ ]. The empty list is represented by any difference-list whose head and tail*
 * are


identical, the most general form being AsnAs.


    Difference-lists are an established logic programming technique. The use of


difference-lists rather than lists can lead to more concise and efficient progr*
 *ams.


The improvement occurs because of the combining property of difference-lists.




248   Incomplete Data Structures                                15.1



Two incomplete difference-lists can be concatenated to give a third difference-*
 *list


in constant time. In contrast, lists are concatenated using the standard append


program in time linear in the length of the first list.



               Figure 15.1:  Concatenating difference-lists



    Consider Figure 15.1.  The difference-list XsnZs is the result of appending


the difference-list YsnZs to the difference-list XsnYs. This can be expressed as


a single fact. Program 15.1 defines a predicate append_dl(As,Bs,Cs), which is


true if the difference-list Cs is the result of appending the difference-list B*
 *s to the


difference-list As. We use the suffix _dl to denote a variant of a predicate th*
 *at


uses difference-lists.


    A necessary and sufficient condition characterizing when two difference-lis*
 *ts


AsnBs and XsnYs can be concatenated using Program 15.1 is that Bs be unifiable


with Xs.  In that case, the two difference-lists are compatible.  If the tail o*
 *f a


difference-list is uninstantiated, it is compatible with any difference-list. F*
 *urther-




15.1                                              Difference-Lists249



        append_dl(As,Bs,Cs)  


            The difference-list Cs is the result of appending Bs to As,


            where As and Bs are compatible difference-lists.


        append_dl(XsnYs, YsnZs, XsnZs).



        Program 15.1:  Concatenating difference-lists



more, in such a case Program 15.1 would concatenate it in constant time.  For


example, the result of the query append_dl([a,b,cjXs]nXs,[1,2]n[ ],Ys)? is


(Xs=[1,2],Ys=[a,b,c,1,2]n[ ]).



    Difference-lists are the logic programming counterpart of Lisp's rplacd, wh*
 *ich


is also used to concatenate lists in constant time and save consing (allocating*
 * new


list-cells).  There is a difference between the two:  the former are free of si*
 *de


effects and can be discussed in terms of the abstract computation model, whereas


rplacd is a destructive operation, which can be described only by reference to *
 *the


machine representation of S-expressions.



    A good example of a program that can be improved by using difference-lists


is Program 9.1a for flattening a list. It uses double recursion to flatten sepa*
 *rately


the head and tail of a list of lists, then concatenates the results. We adapt t*
 *hat


program to compute the relation flatten_dl(Xs,Ys), where Ys is a difference-list


representing the elements that appear in a list of lists Xs in correct order. T*
 *he


direct translation of Program 9.1a to use difference-lists follows:



        flatten_dl([XjXs],YsnZs)  




250   Incomplete Data Structures                                15.1



            flatten_dl(X,AsnBs), flatten_dl(Xs,CsnDs),


            append_dl(AsnBs,CsnDs,YsnZs).


        flatten_dl(X,[XjXs]nXs)  


            constant(X), X6=[ ].


        flatten_dl([ ],XsnXs).



The doubly recursive clause can be simplified by unfolding the append_dl goal


with respect to its definition in Program 15.1.  Unfolding is discussed in more


detail in Chapter 18 on program transformation. The result is



        flatten_dl([XjXs],AsnDs)  


            flatten_dl(X,AsnBs), flatten_dl(Xs,BsnDs).



The program for flatten_dl can be used to implement flatten by expressing the


connection between the desired flattened list and the difference-list computed *
 *by


flatten_dl as follows:



        flatten(Xs,Ys)   flatten_dl(Xs,Ysn[ ]).



Collecting the program and renaming variables yields Program 15.2.


    Declaratively Program 15.2 is straightforward. The explicit call to append *
 *is


made unnecessary by flattening the original list of lists into a difference-lis*
 *t rather


than a list. The resultant program is more efficient, because the size of its p*
 *roof


tree is linear in the number of elements in the list of lists rather than quadr*
 *atic.


    The operational behavior of programs using difference-lists, such as Pro-


gram 15.2, is harder to understand. The flattened list seems to be built by mag*
 *ic.




15.1                                              Difference-Lists251


        flatten(Xs,Ys)  


            Ys is a flattened list containing the elements in Xs.


        flatten(Xs,Ys)   flatten_dl(Xs,Ysn[ ]).


        flatten_dl([XjXs],YsnZs)  


            flatten_dl(X,YsnYs1), flatten_dl(Xs,Ys1nZs).


        flatten_dl(X,[XjXs]nXs)  


            constant(X), X6=[ ].


        flatten_dl([ ],XsnXs).



        Program 15.2:  Flattening a list of lists using difference-lists



    Let us investigate the program in action. Figure 15.2 is a trace of the que*
 *ry


flatten([[a],[b,[c]]],Xs)? with respect to Program 15.2.


    The trace shows that the output, Xs, is built top-down (in the terminology


of Section 7.5).  The tail of the difference-list acts like a pointer to the en*
 *d of


the incomplete structure.  The pointer gets set by unification.  By using these


\pointers" no intermediate structures are built, in contrast to Program 9.1a.


    The discrepancy between clear declarative understanding and difficult proce-


dural understanding stems from the power of the logical variable. We can specify


logical relations implicitly and leave their enforcement to Prolog. Here the co*
 *n-


catenation of the difference-lists has been expressed implicitly, and it is mys*
 *terious


when it happens in the program.


    Building structures with difference-lists is closely related to building st*
 *ruc-


tures with accumulators. Loosely, difference-lists build structures top-down, w*
 *hile




252   Incomplete Data Structures                                15.1



 flatten([[a],[b,[c]]],Xs)


     flatten_dl([[a],[b,[c]]],Xsn[ ])


         flatten_dl([a],XsnXs1)


            flatten_dl(a,XsnXs2)                      Xs = [ajXs2]


                constant(a)


                a 6= [ ]


            flatten_dl([],Xs2nXs1)                    Xs2 = Xs1


         flatten_dl([[b,[c]]],Xs1n[ ])


            flatten_dl([b,[c]],Xs1nXs3)


                flatten_dl(b,Xs1nXs4)                 Xs1 = [bjXs4]


                    constant(b)


                    b 6= [ ]


                flatten_dl([[c]],Xs4nXs3)


                    flatten_dl([c],Xs4nXs5)


                        flatten_dl(c,Xs4nXs6)         Xs4 = [cjXs6]


                           constant(c)


                           c 6= [ ]


                        flatten_dl([ ],Xs6nXs5)       Xs6 = Xs5


                    flatten_dl([ ],Xs5nXs3)           Xs5 = Xs3


                flatten_dl([ ],Xs3n[ ])               Xs3 = [ ]


            Output:  Xs = [a,b,c]



         Figure 15.2:  Tracing a computation using difference-lists



accumulators build structures bottom-up. Exercise 9.1(i) asked for a doubly re-




15.1                                              Difference-Lists253



cursive version of flatten that avoided the call to append by using accumulator*
 *s.


A solution is the following program:



        flatten(Xs,Ys)   flatten(Xs,[ ],Ys).


        flatten([XjXs],Zs,Ys)  


            flatten(Xs,Zs,Ys1), flatten(X,Ys1,Ys).


        flatten(X,Xs,[XjXs])  


            constant(X), X6=[ ].


        flatten([ ],Xs,Xs).



The similarity of this program to Program 15.2 is striking. There are only two


differences between the programs. The first difference is syntactic. The differ*
 *ence-


list is represented as two arguments, but in reverse order, the tail preceding *
 *the


head. The second difference is the goal order in the recursive clause of flatte*
 *n.


The net effect is that the flattened list is built bottom-up from its tail rath*
 *er than


top-down from its head.



    We give another example of the similarity between difference-lists and accu-


mulators. Program 15.3 is a translation of naive reverse (Program 3.16a) where


lists have been replaced by difference-lists, and the append operation has been


unfolded away.



    When are difference-lists the appropriate data structure for Prolog program*
 *s?


Programs with explicit calls to append can usually gain in efficiency by using


difference-lists rather than lists. A typical example is a doubly recursive pro*
 *gram


where the final result is obtained by appending the outputs of the two recursive




254   Incomplete Data Structures                                15.1


        reverse(Xs,Ys)  


            Ys is the reversal of the list Xs.


        reverse(Xs,Ys)   reverse_dl(Xs,Ysn[ ]).


        reverse_dl([XjXs],YsnZs)  


            reverse_dl(Xs,Ysn[XjZs]).


        reverse_dl([ ],XsnXs).



        Program 15.3:  Reverse with difference-lists



calls. More generally, a program that independently builds different sections o*
 *f a


list to be later combined is a good candidate for using difference-lists.


    The logic program for quicksort, Program 3.22, is an example of a doubly


recursive program where the final result, a sorted list, is obtained from conca*
 *te-


nating two sorted sublists. It can be made more efficient by using difference-l*
 *ists.


All the append operations involved in combining partial results can be performed


implicitly, as shown in Program 15.4.


    The call of quicksort_dl by quicksort is an initializing call, as for flatt*
 *en


in Program 15.2.  The recursive clause is the quicksort algorithm interpreted


for difference-lists where the final result is pieced together implicitly rathe*
 *r than


explicitly. The base clause of quicksort_dl states that the result of sorting an


empty list is the empty difference-list.  Note the use of unification to place *
 *the


partitioning element X after the smaller elements Ys and before the bigger elem*
 *ents


Ys1 in the call quicksort_dl(Littles,Ysn[XjYs1]).


    Program 15.4 is derived from Program 3.22 in exactly the same way as Pro-




15.1                                              Difference-Lists255



        quicksort(List,SortedList)  


            SortedList is an ordered permutation of List.


        quicksort(Xs,Ys)   quicksort_dl(Xs,Ysn[ ]).


        quicksort_dl([XjXs],YsnZs)  


            partition(Xs,X,Littles,Bigs),


            quicksort_dl(Littles,Ysn[XjYs1]),


            quicksort_dl(Bigs,Ys1nZs).


        quicksort_dl([ ],XsnXs).


        partition(Xs,X,Ls,Bs)   See Program 3.22.



        Program 15.4:  Quicksort using difference-lists



gram 15.2 is derived from Program 9.1a. Lists are replaced by difference-lists *
 *and


the append_dl goal unfolded away. The initial call of quicksort_dl by quick-


sort expresses the relation between the desired sorted list and the computed


sorted difference-list.



    An outstanding example of using difference-lists to advantage is a solution*
 * to


a simplified version of Dijkstra's Dutch flag problem. The problem reads: \Given


a list of elements colored red, white, or blue, reorder the list so that all th*
 *e red


elements appear first, then all the white elements, followed by the blue elemen*
 *ts.


This reordering should preserve the original relative order of elements of the *
 *same


color." For example, the list [red(1),white(2),blue(3),red(4),white(5)]


should be reordered to [red(1),red(4),white(2),white(5),blue(3)].




256   Incomplete Data Structures                                15.1



    Program 15.5 is a simple-minded solution to the problem that collects the


elements in three separate lists, then concatenates the lists. The basic relati*
 *on


is dutch(Xs,Ys), where Xs is the original list of colored elements and Ys is the


reordered list separated into colors.



    The heart of the program is the procedure distribute, which constructs


three lists, one for each color.  The lists are built top-down.  The two calls *
 *to


append can be removed by having distribute build three distinct difference-lists


instead of three lists. Program 15.6 is an appropriately modified version of the


program.



    The implicit concatenation of the difference-lists is done in the initializ*
 *ing


call to distribute_dls by dutch. The complete list is finally \assembled" from


its parts with the satisfaction of the base clause of distribute_dls.



    The Dutch flag example demonstrates a program that builds parts of the


solution independently and pieces them together at the end. It is a more complex


use of difference-lists than the earlier examples.



    Although it makes the program easier to read, the use of an explicit constr*
 *uc-


tor such as n for difference-lists incurs noticeable overhead in time and space*
 *. Us-


ing two separate arguments to represent the difference-list is more efficient. *
 *When


important, this efficiency can be gained by straightforward manual or automatic


transformation.



Exercises for Section 15.1




15.1                                              Difference-Lists257



dutch(Xs,RedsWhitesBlues)  


    RedsWhitesBlues is a list of elements of Xs ordered


    by color: red, then white, then blue.


dutch(Xs,RedsWhitesBlues)  


    distribute(Xs,Reds,Whites,Blues),


    append(Whites,Blues,WhitesBlues),


    append(Reds,WhitesBlues,RedsWhitesBlues).


distribute(Xs,Reds,Whites,Blues)  


    Reds, Whites, and Blues are the lists of the red, white,


    and blue elements in Xs, respectively.


distribute([red(X)jXs],[red(X)jReds],Whites,Blues)  


    distribute(Xs,Reds,Whites,Blues).


distribute([white(X)jXs],Reds,[white(X)jWhites],Blues)  


    distribute(Xs,Reds,Whites,Blues).


distribute([blue(X)jXs],Reds,Whites,[blue(X)jBlues])  


    distribute(Xs,Reds,Whites,Blues).


distribute([ ],[ ],[ ],[ ]).


append(Xs,Ys,Zs)   See Program 3.15.



Program 15.5:  A solution to the Dutch flag problem



dutch(Xs,RedsWhitesBlues)  


    RedsWhitesBlues is a list of elements of Xs ordered


    by color: red, then white, then blue.


dutch(Xs,RedsWhitesBlues)  


    distribute_dls(Xs,RedsWhitesBluesnWhitesBlues,


        WhitesBluesnBlues,Bluesn[ ]).


distribute_dls(Xs,Reds,Whites,Blues)  


    Reds, Whites, and Blues are the difference-lists of the


    red, white, and blue elements in Xs, respectively.


distribute_dls([red(X)jXs],[red(X)jReds]nReds1,Whites,Blues)  


    distribute_dls(Xs,RedsnReds1,Whites,Blues).


distribute_dls([white(X)jXs],Reds,[white(X)jWhites]nWhites1,Blues)  


    distribute_dls(Xs,Reds,WhitesnWhites1,Blues).


distribute_dls([blue(X)jXs],Reds,Whites,[blue(X)jBlues]nBlues1)  


    distribute_dls(Xs,Reds,Whites,BluesnBlues1).


distribute_dls([ ],RedsnReds,WhitesnWhites,BluesnBlues).



Program 15.6:  Dutch flag with difference-lists




258   Incomplete Data Structures                                15.1



(i) Rewrite Program 15.2 so that the final list of elements is in the reverse o*
 *rder


    to how they appear in the list of lists.


(ii)Rewrite Programs 3.27 for preorder(Tree,List), inorder(Tree,List) and


    postorder(Tree,List), which collect the elements occurring in a binary


    tree, to use difference-lists and avoid an explicit call to append.


(iii)Rewrite Program 12.3 for solving the Towers of Hanoi so that the list of


    moves is created as a difference-list rather than a list.



15.2   Difference-Structures



    The concept underlying difference-lists is the use of the difference between


incomplete data structures to represent partial results of a computation.  This


can be applied to recursive data types other than lists. This section looks at a


specific example, sum expressions.


    Consider the task of normalizing sum expressions. Figure 15.3 contains two


sums (a + b) + (c + d) and (a + (b + (c + d))) (Standard Prolog syntax brackets*
 * the


term a + b + c as ((a + b) + c). We describe a procedure converting a sum into a


normalized one that is bracketed to the right. For example, the expression on t*
 *he


left in Figure 15.3 would be converted to the one on the right. Such a procedure


is useful for doing algebraic simplification, facilitating writing programs to *
 *test


whether two expressions are equivalent.


    We introduce a difference-sum as a variant of a difference-list. A differen*
 *ce-


sum is represented as a structure E1 ++ E2 , where E1 and E2 are incomplete




15.2                                          Difference-Structures259



                          +            +


                         / n           / n


                         +  +          a  +


                        / n / n          / n


                       a  b c  d         b  +


                                         / n


                                         c  +


                                           / n


                                           d  0


            Figure 15.3:  Unnormalized and normalized sums



    normalize(Sum,NormalizedSum)  


        NormalizedSum is the result of normalizing the sum expression Sum.


    normalize(Exp,Norm)   normalize_ds(Exp,Norm++0).


    normalize_ds(A+B,Norm++Space)  


        normalize_ds(A,Norm++NormB), normalize_ds(B,NormB++Space).


    normalize_ds(A,(A+Space)++Space)  


        constant(A).



    Program 15.7:  Normalizing plus expressions



normalized sums. It is assumed that ++ is defined as a binary infix operator. It


is convenient to use 0 to indicate an empty sum.



    Program 15.7 is a program for normalizing sums.  The relation scheme is




260   Incomplete Data Structures                                15.2



normalize(Exp,Norm), where Norm is an expression equivalent to Exp that is


bracketed to the right and preserves the order of the constants appearing in Ex*
 *p.



    This program is similar in structure to Program 15.2 for flattening lists u*
 *sing


difference-lists. There is an initialization stage, where the difference-struct*
 *ure is


set up, typically calling a predicate with the same name but different arity or


different argument pattern. The base case passes out the tail of the incomplete


structure, and the goals in the body of the recursive clause pass the tail of t*
 *he


first incomplete structure to be the head of the second.



    The program builds the normalized sum top-down.  By analogy with the


programs using difference-lists, the program can be easily modified to build the


structure bottom-up, which is Exercise (ii) at the end of this section.



    The declarative reading of these programs is straightforward. Operationally


the programs can be understood in terms of building a structure incrementally,


where the \hole" for further results is referred to explicitly.  This is entire*
 *ly


analogous to difference-lists.



Exercises for Section 15.2



(i) Define the predicate normalized_sum(Expression), which is true if Expres-


    sion is a normalized sum.



(ii)Rewrite Program 15.7 so that


        (a) The normalized sum is built bottom-up;


        (b) The order of the elements is reversed.




15.3                                                 Dictionaries261



(iii)Enhance Program 15.7 so that numbers appearing in the addends are added


    together and returned as the first component of the normalized sum.  For


    example, (3 + x) + 2 + (y + 4) should be normalized to 9 + (x + y).


(iv)Write a program to normalize products using difference-products, defined


    analogously to difference-sums.



15.3   Dictionaries



    A different use of incomplete data structures enables the implementation of


dictionaries. Consider the task of creating, using, and maintaining a set of va*
 *lues


indexed under keys.  There are two main operations we would like to perform:


looking up a value stored under a certain key, and entering a new key and its


associated value. These operations must ensure consistency | for example, the


same key should not appear twice with two different values.  It is possible to


perform both operations, looking up values of keys, and entering new keys, with


a single simple procedure by exploiting incomplete data structures.


    Consider a linear sequence of key-value pairs. Let us see the advantages of


using an incomplete data structure for its representation. Program 15.8 defines


the relation lookup(Key,Dictionary,Value) which is true if the entry under Key


in the dictionary Dictionary has value Value. The dictionary is represented as


an incomplete list of pairs of the form (Key,Value).


    Let us consider an example where the dictionary is used to remember phone


extensions keyed under the names of people.  Suppose that Dict is initially




262   Incomplete Data Structures                                15.3


        lookup(Key,Dictionary,Value)  


            Dictionary contains Value indexed under Key.


            Dictionary is represented as an incomplete


            list of pairs of the form (Key,Value).


        lookup(Key,[(Key,Value)jDict],Value).


        lookup(Key,[(Key1,Value1)jDict],Value)  


            Key 6= Key1, lookup(Key,Dict,Value).



        Program 15.8:  Dictionary lookup from a list of tuples



instantiated to [(arnold,8881),(barry,4513),(cathy,5950)jXs].  The query


lookup(arnold,Dict,N)? has as answer N=8881 and is used for finding Arnold's


phone number. The query lookup(barry,Dict,4513)? succeeds, checking that


Barry's phone number is 4513.


    The  entry  of  new  keys  and  values  is  demonstrated  by  the  query


lookup(david,Dict,1199)?. Syntactically this appears to check David's phone


number.   Its  effect  is  different.   The  query  succeeds,  instantiating  D*
 *ict


to [(arnold,8881),(barry,4513),(cathy,5950),(david,1199)jXs1].  Thus


lookup has entered a new value.


    What happens if we check Cathy's number with the query lookup(cathy,


Dict,5951)?, where the number is incorrect?  Rather than entering a second


entry for Cathy, the query fails because of the test Key 6= Key1.


    The lookup procedure given in Program 15.8 completes Program 14.15, the


simplified ELIZA. Note that when the program begins, the dictionary is empty,




15.3                                                 Dictionaries263



indicated by its being a variable. The dictionary is built up during the matchi*
 *ng


against the stimulus half of a stimulus-response pair. The constructed dictiona*
 *ry


is used to produce the correct response.  Note that entries are placed in the


dictionary without their values being known: a striking example of the power of


logical variables. Once an integer is detected, it is put in the dictionary, an*
 *d its


value is determined later.


    Searching linear lists is not very efficient for a large number of key-valu*
 *e pairs.


Ordered binary trees allow more efficient retrieval of information than linear *
 *lists.


The insight that an incomplete structure can be used to allow entry of new keys


as well as to look up values carries over to binary trees.


    The binary trees of Section 3.4 are modified to be a four-place structure


dict(Key,Value,Left,Right), where Left and Right are, respectively, the left


and right subdictionaries, and Key and Value are as before. The functor dict is


used to suggest a dictionary.


    Looking up in the dictionary tree has a very elegant definition, similar in*
 * spirit


to Program 15.8. It performs recursion on binary trees rather than on lists, and


relies on unification to instantiate variables to dictionary structures. Progra*
 *m 15.9


gives the procedure lookup(Key,Dictionary,Value), which as before both looks


up the value corresponding to a given key and enters new values.


    At each stage, the key is compared with the key of the current node. If it


is less, the left branch is recursively checked; if it is greater, the right br*
 *anch is


taken. If the key is non-numeric, the predicates < and > must be generalized.


The cut is necessary in Program 15.9, in contrast to Program 15.8, because of t*
 *he




264   Incomplete Data Structures                                15.3



        lookup(Key,Dictionary,Value)  


            Dictionary contains Value indexed under Key.


            Dictionary is represented as an ordered binary tree.


        lookup(Key,dict(Key,X,Left,Right),Value)  


            !, X = Value.


        lookup(Key,dict(Key1,X,Left,Right),Value)  


            Key < Key1, lookup(Key,Left,Value).


        lookup(Key,dict(Key1,X,Left,Right),Value)  


            Key > Key1, lookup(Key,Right,Value).



        Program 15.9:  Dictionary lookup in a binary tree



nonlogical nature of comparison operators, which will give errors if keys are n*
 *ot


instantiated.



    Given a number of pairs of keys and values, the dictionary they determine is


not unique. The shape of the dictionary depends on the order in which queries


are posed to the dictionary.



    The dictionary can be used to melt a term that has been frozen using Pro-


gram 10.8 for numbervars.  The code is given as Program 15.10.  Each melted


variable is entered into the dictionary, so that the correct shared variables w*
 *ill be


assigned.



15.4   Queues




15.4                                                     Queues 265



        freeze(A,B)  


            Freeze term A into B.


        freeze(A,B)  


            copy_term(A,B), numbervars(B,0,N).


        melt_new(A,B)  


            Melt the frozen term A into B.


        melt_new(A,B)  


            melt(A,B,Dictionary), !.


        melt(`$VAR'(N),X,Dictionary)  


            lookup(N,Dictionary,X).


        melt(X,X,Dictionary)  


            constant(X).


        melt(X,Y,Dictionary)  


            compound(X),


            functor(X,F,N),


            functor(Y,F,N),


            melt(N,X,Y,Dictionary).


        melt(N,X,Y,Dictionary)  


            N > 0,


            arg(N,X,ArgX),


            melt(ArgX,ArgY,Dictionary),


            arg(N,Y,ArgY),


            N1 is N-1,


            melt(N1,X,Y,Dictionary).


        melt(0,X,Y,Dictionary).


        numbervars(Term,N1,N2)   See Program 10.8.


        lookup(Key,Dictionary,Value)   See Program 15.9.



        Program 15.10:  Melting a term




266   Incomplete Data Structures                                15.4



    An interesting application of difference-lists is to implement queues. A qu*
 *eue


is a first-in, first-out store of information. The head of the difference-list *
 *represents


the beginning of the queue, the tail represents the end of the queue, and the


members of the difference-list are the elements in the queue. A queue is empty *
 *if


the difference-list is empty, that is, if its head and tail are identical.



    Maintaining a queue is different from maintaining a dictionary. We consider


the relation queue(S), where a queue processes a stream of commands, repre-


sented as a list S. There are two basic operations on a queue | enqueuing an


element and dequeuing an element | represented, respectively, by the structures


enqueue(X) and dequeue(X), where X is the element concerned.



    Program  15.11  implements  the  operations  abstractly.   The  predicate


queue(S) calls queue(S,Q), where Q is initialized to an empty queue. queue/2


is an interpreter for the stream of enqueue and dequeue commands, responding


to each command and updating the state of the queue accordingly. Enqueuing


an element exploits the incompleteness of the tail of the queue, instantiating *
 *it to


a new element and a new tail, which is passed as the updated tail of the queue.


Clearly, the calls to enqueue and dequeue can be unfolded, resulting in a more


concise and efficient, but perhaps less readable, program.



    The program terminates when the stream of commands is exhausted. It can


be extended to insist that the queue be empty at the end of the commands by


changing the base fact to



        queue([ ],Q)   empty(Q).




15.4                                                     Queues 267



        queue(S)  


            S is a sequence of enqueue and dequeue operations,


            represented as a list of terms enqueue(X ) and dequeue(X ).


        queue(S)   queue(S,QnQ).


        queue([enqueue(X)jXs],Q)  


            enqueue(X,Q,Q1), queue(Xs,Q1).


        queue([dequeue(X)jXs],Q)  


            dequeue(X,Q,Q1), queue(Xs,Q1).


        queue([ ],Q).


        enqueue(X,Qhn[XjQt],QhnQt).


        dequeue(X,[XjQh]nQt,QhnQt).



        Program 15.11:  A queue process



A queue is empty if both its head and tail can be instantiated to the empty


list, expressed by the fact empty([ ]n[ ]). Logically, the clause empty(XsnXs)


would also be sufficient; however, because of the lack of the occurs check in P*
 *rolog,


discussed in Chapter 4, it may succeed erroneously on a nonempty queue, creating


a cyclic data structure.



    We demonstrate the use of queues in Program 15.12 for flattening a list.


Although the example is somewhat contrived, it shows how queues can be used.


The program does not preserve the order of the elements in the original list.



    The basic relation is flatten_q(Ls,Q,Xs), where Ls is the list of lists to




268   Incomplete Data Structures                                15.4



        flatten(Xs,Ys)  


            Ys is a flattened list containing the elements in Xs.


        flatten(Xs,Ys)   flatten_q(Xs,QsnQs,Ys).


        flatten_q([XjXs],Psn[XsjQs],Ys)  


            flatten_q(X,PsnQs,Ys).


        flatten_q(X,[QjPs]nQs,[XjYs])  


            constant(X), X6=[ ], flatten_q(Q,PsnQs,Ys).


        flatten_q([ ],Q,Ys)  


            non_empty(Q), dequeue(X,Q,Q1), flatten_q(X,Q1,Ys).


        flatten_q([ ],[ ]n[ ],[ ]).


        non_empty([ ]n[ ])   !, fail.


        non_empty(Q).


        dequeue(X,[XjQh]nQt,QhnQt).



        Program 15.12:  Flattening a list using a queue



be flattened, Q is the queue of lists waiting to be flattened, and Xs is the li*
 *st


of elements in Ls.  The initial call of flatten_q/3 by flatten/2 initializes an


empty queue. The basic operation is enqueuing the tail of the list and recursiv*
 *ely


flattening the head of the list:


        flatten_q([XjXs],Q,Ys)   enqueue(Xs,Q,Q1), flatten_q(X,Q1,Ys).



The explicit call to enqueue can be omitted and incorporated via unification as


follows:




15.4                                                     Queues 269



        flatten_q([XjXs],Qhn[XsjQt],Ys)   flatten_q(X,QhnQt,Ys).



If the element being flattened is a constant, it is added to the output structu*
 *re


being built top-down, and an element is dequeued (by unifying with the head of


the difference-list) to be flattened in the recursive call:


        flatten_q(X,[QjQh]nQt,[XjYs])  


            constant(X), X6=[ ], flatten_q(Q,QhnQt,Ys).



When the empty list is being flattened, either the top element is dequeued


        flatten_q([ ],Q,Ys)  


            non_empty(Q), dequeue(X,Q,Q1), flatten_q(X,Q1,Ys).



or the queue is empty, and the computation terminates:


        flatten_q([ ],[ ]n[ ],[ ]).



    A previous version of Program 15.12 incorrectly expressed the case when the


list was empty, and the top element was dequeued as


        flatten_q([ ],[QjQh]nQt,Ys)   flatten_q(Q,QhnQt,Ys).



This led to a nonterminating computation, since an empty queue QsnQs unified


with [QjQh]nQt and so the base case was never reached.


    Let us reconsider Program 15.11 operationally. Under the expected use of a


queue, enqueue(X) messages are sent with X determined and dequeue(X) with X


undetermined. As long as more elements are enqueued than dequeued, the queue


behaves as expected, with the difference between the head of the queue and the




270   Incomplete Data Structures                                15.4



tail of the queue being the elements in the queue.  However, if the number of


dequeue messages received exceeds that of enqueue messages, an interesting thing


happens | the content of the queue becomes negative.  The head runs ahead


of the tail, resulting in a queue containing a negative sequence of undetermined


elements, one for each excessive dequeue message.


    It is interesting to observe that this behavior is consistent with the asso*
 *cia-


tivity of appending of difference-lists. If a queue Qsn[X1,X2,X3jQs] that conta*
 *ins


minus three undetermined elements has the queue [a,b,c,d,ejXs]nXs that con-


tains five elements appended to it, then the result will be the queue [d,ejXs]n*
 *Xs


with two elements, where the \negative" elements X1,X2,X3 are unified with


a,b,c.



15.5   Background



    Difference-lists have been in the logic programming folklore since its ince*
 *p-


tion. The first description of them in the literature is given by Clark and Tar*
 *nlund


(1977).


    The automatic transformation of simple programs without difference-lists to


programs with difference-lists, for example, reverse and flatten, can be found


in Bloch (1984).


    Section 15.1 implicitly contains an algorithm for converting from a program


with explicit calls to append to an equivalent, more efficient program that uses


difference-lists to concatenate the elements and which is much more efficient.




15.5                                                 Background 271



Care is needed in application of the algorithm. There are excellent discussions*
 * of


a correct algorithm and the dangers of using difference-lists without the occurs


check in Sondergaard(1990) amd Marriott and Sondergaard (1993).


    There is an interesting discussion of the Dutch flag problem in O'Keefe (19*
 *90).


    Automatic removal of a functor denoting difference-lists is described in Ga*
 *l-


lagher and Bruynooghe (1990).


    Maintaining dictionaries and queues can be given a theoretical basis as a


perpetual process, as described by Warren (1982) and Lloyd (1987).


    Queues are particularly important in concurrent logic programming lan-


guages, since their input need not be a list of requests but a stream, which is


generated incrementally by the processes requesting the services of the queue.
