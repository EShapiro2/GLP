



                                                Chapter  23



                            An  Equation  Solver



    A very natural area for Prolog applications is symbolic manipulation.  For


example, a Prolog program for symbolic differentiation, a typical symbol manip-


ulation task, is just the rules of differentiation in different syntax, as show*
 *n in


Program 3.30.


    In this chapter, we present a program for solving symbolic equations. It is


a simplification of PRESS (PRolog Equation Solving System), developed in the


mathematical reasoning group of the Department of Artificial Intelligence at the


University of Edinburgh. PRESS performs at the level of a mathematics student


in her final year of high school.


    The first section gives an overview of equation solving with some example


solutions.  The remaining four sections cover the four major equation-solving


methods implemented in the equation solver.



23.1   An Overview of Equation Solving




394   An Equation Solver                                        23.1



    The task of equation solving can be described syntactically. Given an equa-


tion Lhs = Rhs in an unknown X, transform the equation into an equivalent


equation X = Rhs1, where Rhs1 does not contain X. This final equation is the


solution. Two equations are equivalent if one is transformed into the other by a


finite number of applications of the axioms and rules of algebra.



    Successful mathematics students do not solve equations by blindly applying


axioms of algebra.  Instead they learn, develop, and use various methods and


strategies. Our equation solver, modeling this behavior, is accordingly a colle*
 *ction


of methods to be applied to an equation to be solved. Each method transforms


the equation by applying identities of algebra expressed as rewrite rules.  The


methods can and do take widely different forms. They can be a collection of rul*
 *es


for solving the class of equations to which the method is applicable, or algori*
 *thms


implementing a decision procedure.



    Abstractly, a method has two parts: a condition testing whether the method


is applicable, and the application of the method itself.



    The type of equations our program can handle are indicated by the three


examples in Figure 23.1.  They consist of algebraic functions of the unknown,


that is +, {, , /, and exponentiation to an integer power, and also trigonometr*
 *ic


and exponential functions. The unknown is x in all three equations.



    We briefly show how each equation is solved.



    The first step in solving equation (i) in Figure 23.1 is factorization.  The


problem to be solved is reduced to solving cos(x) = 0 and 1  2  sin(x) = 0. A




23.1                                An Overview of Equation Solving395



                    (i)  cos(x)  (1  2  sin(x)) = 0


                    (ii) x2  3  x + 2 = 0


                    (iii)22x  5  2x+1 + 16 = 0


                     Figure 23.1:  Test equations



solution to either of these equations is a solution to the original equation.


    Both the equations cos(x) = 0 and 1  2  sin(x) = 0 are solved by making


x the subject of the equation.  This is possible because x occurs once in each


equation.


    The solution to cos(x) = 0 is arccos(0). The solution of 1  2  sin(x) = 0


takes the following steps:



        1  2  sin(x) = 0,


        2  sin(x) = 1,


        sin(x) = 1=2,


        x = arcsin(1=2).



In general, equations with a single occurrence of the unknown can be solved by


an algorithmic method called isolation. The method repeatedly applies an appro-


priate inverse function to both sides of the equation until the single occurren*
 *ce


of the unknown is isolated on the left-hand side of the equation. Isolation sol*
 *ves


1  2  sin(x) = 0 by producing the preceding sequence of equations.


    Equation (ii) in Figure 23.1, x2  3  x + 2 = 0, is a quadratic equation in


x.  We all learn in high school a formula for solving quadratic equations.  The




396   An Equation Solver                                        23.1



discriminant, b2  4  a  c, is calculated, in this case (3)2  4  1  2, which
                                                  p_
equals 1, and two solutions are given: x = ((3) +  1)=2, which equals 2, and
          p_
x = ((3)   1)=2, which equals 1.



    The key to solving equation (iii) in Figure 23.1 is to realize that the equ*
 *ation


is really a quadratic equation in 2x. The equation 22x  5  2x+1 + 16 = 0 can


be rewritten as (2x)2  5  2  2x + 16 = 0. This can be solved for 2x, giving two


solutions of the form 2x =Rhs, where Rhs is free of x. Each of these equations


are solved for x to give solutions to equation (iii).



    PRESS was tested on equations taken from British A-level examinations


in mathematics.  It seems that examiners liked posing questions such as equa-


tion (iii), which involved the student`s manipulating logarithmic, exponential,*
 * or


other transcendental functions into forms where they could be solved as poly-


nomials.  A method called homogenization evolved to solve equations of these


types.



    The aim of homogenization is to transform the equation into a polynomial in


some term containing the unknown. (We simplify the more general homogeniza-


tion of PRESS for didactic purposes.) The method consists of four steps, which


we illustrate for equation (iii). The equation is first parsed and all maximal *
 *non-


polynomial terms containing the unknown are collected with duplicates removed.


This set is called the offenders set. In the example, it is f22x; 2x+1g. The se*
 *cond


step is finding a term, known as the reduced term. The result of homogenization


is a polynomial equation in the reduced term. The reduced term in our example


is 2x. The third step of homogenization is finding rewrite rules that express e*
 *ach




23.2                                                Factorization397



of the elements of the offenders set as a polynomial in the reduced term. Find-


ing such a set guarantees that homogenization will succeed. In our example the


rewrite rules are 22x = (2x)2 and 2x+1 = 2  2x.  Finally, the rewrite rules are


applied to produce the polynomial equation.


    We complete this section with a brief overview of the equation solver. The


basic predicate is solve_equation(Equation,X,Solution). The relation is true


if Solution is a solution to Equation in the unknown X. The complete code


appears as Program 23.1.


    Program 23.1 has four clauses for solve_equation, one for each of the four


methods needed to solve the equations in Figure 23.1. More generally, there is


a clause for each equation-solving method. The full PRESS system has several


more methods.


    Our equation solver ignores several features that might be expected. There


is no simplification of expressions, no rational arithmetic, no record of the l*
 *ast


equation solved, no help facility, and so forth. PRESS does contain many of the*
 *se


facilities as discussed briefly in Section 23.6.



23.2   Factorization



    Factorization is the first method attempted by the equation solver. Note th*
 *at


the test whether factorization is applicable is trivial, being unification with*
 * the


equation A  B = 0. If the test succeeds, the simpler equations are recursively


solved. The top-level clause implementing factorization is




398   An Equation Solver                                        23.2



solve_equation(Equation,Unknown,Solution)  


    Solution is a solution to the equation Equation in the unknown Unknown.


solve_equation(AB=0,X,Solution)  


    !,


    factorize(AB,X,Factorsn[ ]),


    remove_duplicates(Factors,Factors1),


    solve_factors(Factors1,X,Solution).


solve_equation(Equation,X,Solution)  


    single_occurrence(X,Equation),


    !,


    position(X,Equation,[SidejPosition]),


    maneuver_sides(Side,Equation,Equation1),


    isolate(Position,Equation1,Solution).


solve_equation(Lhs=Rhs,X,Solution)  


    polynomial(Lhs,X),


    polynomial(Rhs,X),


    !,


    polynomial_normal_form(Lhs-Rhs,X,PolyForm),


    solve_polynomial_equation(PolyForm,X,Solution).


solve_equation(Equation,X,Solution)  


    homogenize(Equation,X,Equation1,X1),


    !,


    solve_equation(Equation1,X1,Solution1),


    solve_equation(Solution1,X,Solution).


The factorization method


factorize(Expression,Subterm,Factors)  


    Factors is a difference-list consisting of the factors of


    the   multiplicative   term Expression that   contain   the   Subterm.


factorize(AB,X,FactorsnRest)  


    !, factorize(A,X,FactorsnFactors1), factorize(B,X,Factors1nRest).


factorize(C,X,[CjFactors]nFactors)  


    subterm(X,C), !.


factorize(C,X,FactorsnFactors).


solve_factors(Factors,Unknown,Solution)  


    Solution is a solution of the equation Factor = 0 in the


    Unknown for some Factor in the list of Factors.



Program 23.1:  A program for solving equations




23.2                                                Factorization399



solve_factors([FactorjFactors],X,Solution)  


    solve_equation(Factor=0,X,Solution).


solve_factors([FactorjFactors],X,Solution)  


    solve_factors(Factors,X,Solution).


The isolation method


maneuver_sides(1,Lhs = Rhs,Lhs = Rhs)   !.


maneuver_sides(2,Lhs = Rhs,Rhs = Lhs)   !.


isolate([NjPosition],Equation,IsolatedEquation)  


    isolax(N,Equation,Equation1),


    isolate(Position,Equation1,IsolatedEquation).


isolate([ ],Equation,Equation).


Axioms for isolation


isolax(1,-Lhs = Rhs,Lhs = -Rhs).                  % Unary minus


isolax(1,Term1+Term2 = Rhs,Term1 = Rhs-Term2).    % Addition


isolax(2,Term1+Term2 = Rhs,Term2 = Rhs-Term1).    % Addition


isolax(1,Term1-Term2 = Rhs,Term1 = Rhs+Term2).    % Subtraction


isolax(2,Term1-Term2 = Rhs,Term2 = Term1-Rhs).    % Subtraction


isolax(1,Term1Term2 = Rhs,Term1 = Rhs/Term2)      % Multiplication


    Term2 6= 0.


isolax(2,Term1Term2 = Rhs,Term2 = Rhs/Term1)      % Multiplication


    Term1 6= 0.


isolax(1,Term1"Term2 = Rhs,Term1 = Rhs"(-Term2)).


    % Exponentiation


isolax(2,Term1"Term2 = Rhs,Term2 = log(base(Term1),Rhs)).


    % Exponentiation


isolax(1,sin(U) = V,U = arcsin(V)).             % Sine


isolax(1,sin(U) = V,U = ss-arcsin(V)).          % Sine


isolax(1,cos(U) = V,U = arccos(V)).             % Cosine


isolax(1,cos(U) = V,U = -arccos(V)).            % Cosine


The polynomial method


polynomial(Term,X)   See Program 11.4.


polynomial_normal_form(Expression,Term,PolyNormalForm)  


    PolyNormalForm is the polynomial normal form of


    Expression, which is a polynomial in Term.



Program 23.1  (Continued)




400   An Equation Solver                                        23.2



polynomial_normal_form(Polynomial,X,NormalForm)  


    polynomial_form(Polynomial,X,PolyForm),


    remove_zero_terms(PolyForm,NormalForm), !.


polynomial_form(X,X,[(1,1)]).


polynomial_form(X"N,X,[(1,N)]).


polynomial_form(Term1+Term2,X,PolyForm)  


    polynomial_form(Term1,X,PolyForm1),


    polynomial_form(Term2,X,PolyForm2),


    add_polynomials(PolyForm1,PolyForm2,PolyForm).


polynomial_form(Term1-Term2,X,PolyForm)  


    polynomial_form(Term1,X,PolyForm1),


    polynomial_form(Term2,X,PolyForm2),


    subtract_polynomials(PolyForm1,PolyForm2,PolyForm).


polynomial_form(Term1Term2,X,PolyForm)  


    polynomial_form(Term1,X,PolyForm1),


    polynomial_form(Term2,X,PolyForm2),


    multiply_polynomials(PolyForm1,PolyForm2,PolyForm).


polynomial_form(Term"N,X,PolyForm)   !,


    polynomial_form(Term,X,PolyForm1),


    binomial(PolyForm1,N,PolyForm).


polynomial_form(Term,X,[(Term,0)])  


    free_of(X,Term), !.


remove_zero_terms([(0,N)jPoly],Poly1)  


    !, remove_zero_terms(Poly,Poly1).


remove_zero_terms([(C,N)jPoly],[(C,N)jPoly1])  


    C 6= 0, !, remove_zero_terms(Poly,Poly1).


remove_zero_terms([ ],[ ]).


Polynomial manipulation routines


add_polynomials(Poly1,Poly2,Poly)  


    Poly is the sum of Poly1 and Poly2 , where Poly1 ,


    Poly2 , and Poly are all in polynomial form.


add_polynomials([ ],Poly,Poly)   !.


add_polynomials(Poly,[ ],Poly)   !.


add_polynomials([(Ai,Ni)jPoly1],[(Aj,Nj)jPoly2],[(Ai,Ni)jPoly])  


    Ni > Nj, !, add_polynomials(Poly1,[(Aj,Nj)jPoly2],Poly).


add_polynomials([(Ai,Ni)jPoly1],[(Aj,Nj)jPoly2],[(A,Ni)jPoly])  


    Ni =:= Nj, !, A is Ai+Aj, add_polynomials(Poly1,Poly2,Poly).


add_polynomials([(Ai,Ni)jPoly1],[(Aj,Nj)jPoly2],[(Aj,Nj)jPoly])  


    Ni < Nj, !, add_polynomials([(Ai,Ni)jPoly1],Poly2,Poly).



Program 23.1  (Continued)




23.2                                                Factorization401



subtract_polynomials(Poly1,Poly2,Poly)  


    Poly is the difference of Poly1 and Poly2 , where Poly1 ,


    Poly2 , and Poly are all in polynomial form.


subtract_polynomials(Poly1,Poly2,Poly)  


    multiply_single(Poly2,(-1,0),Poly3),


    add_polynomials(Poly1,Poly3,Poly), !.


multiply_single(Poly1,Monomial,Poly)  


    Poly is the product of Poly1 and Monomial, where Poly1


    and Poly are in polynomial form, and Monomial has the


    form (C,N ) denoting the monomial C X N.


multiply_single([(C1,N1)jPoly1],(C,N),[(C2,N2)jPoly])  


    C2 is C1C, N2 is N1+N, multiply_single(Poly1,(C,N),Poly).


multiply_single([ ],Factor,[ ]).


multiply_polynomials(Poly1,Poly2,Poly)  


    Poly is the product of Poly1 and Poly2 , where Poly1 ,


    Poly2 and Poly are all in polynomial form


multiply_polynomials([(C,N)jPoly1],Poly2,Poly)  


    multiply_single(Poly2,(C,N),Poly3),


    multiply_polynomials(Poly1,Poly2,Poly4),


    add_polynomials(Poly3,Poly4,Poly).


multiply_polynomials([ ],P,[ ]).


binomial(Poly,1,Poly).


Polynomial equation solver


solve_polynomial_equation(Equation,Unknown,Solution)  


    Solution is a solution to the polynomial Equation in the unknown Unknown.


solve_polynomial_equation(PolyEquation,X,X = -B/A)  


    linear(PolyEquation), !,


    pad(PolyEquation,[(A,1),(B,0)]).


solve_polynomial_equation(PolyEquation,X,Solution)  


    quadratic(PolyEquation), !,


    pad(PolyEquation,[(A,2),(B,1),(C,0)]),


    discriminant(A,B,C,Discriminant),


    root(X,A,B,C,Discriminant,Solution).


discriminant(A,B,C,D)   D is BB - 4AC.



Program 23.1  (Continued)




402   An Equation Solver                                        23.2



root(X,A,B,C,0,X= -B/(2A)).


root(X,A,B,C,D,X= (-B+sqrt(D))/(2A))   D > 0.


root(X,A,B,C,D,X= (-B-sqrt(D))/(2A))   D > 0.


pad([(C,N)jPoly],[(C,N)jPoly1])  


    !, pad(Poly,Poly1).


pad(Poly,[(0,N)jPoly1])  


    pad(Poly,Poly1).


pad([ ],[ ]).


linear([(Coeff,1)jPoly]).


quadratic([(Coeff,2)jPoly]).


The homogenization method


homogenize(Equation,X,Equation1,X1 )  


    The Equation in X  is transformed to the polynomial


    Equation1 in X1 where X1 , contains X .


homogenize(Equation,X,Equation1,X1)  


    offenders(Equation,X,Offenders),


    reduced_term(X,Offenders,Type,X1),


    rewrite(Offenders,Type,X1,Substitutions),


    substitute(Equation,Substitutions,Equation1).


offenders(Equation,Unknown,Offenders)  


    Offenders is the set of offenders of the Equation in the Unknown.


offenders(Equation,X,Offenders)  


    parse(Equation,X,Offenders1n[ ]),


    remove_duplicates(Offenders1,Offenders),


    multiple(Offenders).


reduced_term(X,Offenders,Type,X1)  


    classify(Offenders,X,Type),


    candidate(Type,Offenders,X,X1).


Heuristics for exponential equations


classify(Offenders,X,exponential)  


    exponential_offenders(Offenders,X).


exponential_offenders([A"BjOffs],X)  


    free_of(X,A), subterm(X,B), exponential_offenders(Offs,X).


exponential_offenders([ ],X).


candidate(exponential,Offenders,X,A"X)  


    base(Offenders,A), polynomial_exponents(Offenders,X).



Program 23.1  (Continued)




23.2                                                Factorization403



base([A"BjOffs],A)   base(Offs,A).


base([ ],A).


polynomial_exponents([A"BjOffs],X)  


    polynomial(B,X), polynomial_exponents(Offs,X).


polynomial_exponents([ ],X).


Parsing the equation and making substitutions


parse(Expression,Term,Offenders)  


    Expression is traversed to produce the set of Offenders in Term,


    that is, the nonalgebraic subterms of Expression containing Term.


parse(A+B,X,L1nL2)  


    !, parse(A,X,L1nL3), parse(B,X,L3nL2).


parse(AB,X,L1nL2)  


    !, parse(A,X,L1nL3), parse(B,X,L3nL2).


parse(A-B,X,L1nL2)  


    !, parse(A,X,L1nL3), parse(B,X,L3nL2).


parse(A=B,X,L1nL2)  


    !, parse(A,X,L1nL3), parse(B,X,L3nL2).


parse(A"B,X,L)  


    integer(B), !, parse(A,X,L).


parse(A,X,LnL)  


    free_of(X,A), !.


parse(A,X,[AjL]nL)  


    subterm(X,A), !.


substitute(Expression,Substitutions,Expression1 )  


    The list of Substitutions is applied to Expression to produce Expression1.


substitute(A+B,Subs,NewA+NewB)  


    !, substitute(A,Subs,NewA), substitute(B,Subs,NewB).


substitute(AB,Subs,NewANewB)  


    !, substitute(A,Subs,NewA), substitute(B,Subs,NewB).


substitute(A-B,Subs,NewA-NewB)  


    !, substitute(A,Subs,NewA), substitute(B,Subs,NewB).


substitute(A=B,Subs,NewA=NewB)  


    !, substitute(A,Subs,NewA), substitute(B,Subs,NewB).


substitute(A"B,Subs,NewA"B)  


    integer(B), !, substitute(A,Subs,NewA).


substitute(A,Subs,B)  


    member(A=B,Subs), !.


substitute(A,Subs,A).



Program 23.1  (Continued)




404   An Equation Solver                                        23.2



Finding homogenization rewrite rules


rewrite([OffjOffs],Type,X1,[Off=TermjRewrites])  


    homogenize_axiom(Type,Off,X1,Term),


    rewrite(Offs,Type,X1,Rewrites).


rewrite([ ],Type,X,[ ]).


Homogenization axioms


homogenize_axiom(exponential,A"(NX),A"X,(A"X)"N).


homogenize_axiom(exponential,A"(-X),A"X,1/(A"X)).


homogenize_axiom(exponential,A"(X+B),A"X,A"BA"X).


Utilities


subterm(Sub,Term)   See Program 9.2.


position(Term,Term,[ ])   !.


position(Sub,Term,Path)  


    compound(Term), functor(Term,F,N), position(N,Sub,Term,Path), !.


position(N,Sub,Term,[NjPath])  


    arg(N,Term,Arg), position(Sub,Arg,Path).


position(N,Sub,Term,Path)  


    N > 1, N1 is N-1, position(N1,Sub,Term,Path).


free_of(Subterm,Term)   occurrence(Subterm,Term,0).


single_occurrence(Subterm,Term)   occurrence(Subterm,Term,1).


occurrence(Term,Term,1)   !.


occurrence(Sub,Term,N)  


    compound(Term), !, functor(Term,F,M), occurrence(M,Sub,Term,0,N).


occurrence(Sub,Term,0)   Term 6= Sub.


occurrence(M,Sub,Term,N1,N2)  


    M > 0, !, arg(M,Term,Arg), occurrence(Sub,Arg,N), N3 is N+N1,


    M1 is M-1, occurrence(M1,Sub,Term,N3,N2).


occurrence(0,Sub,Term,N,N).


remove_duplicates(Xs,Ys)   no_doubles(Xs,Ys).


no_doubles(Xs,Ys)   See Program 7.9.


multiple([X1,X2jXs]).



Program 23.1  (Continued)




23.3                                                    Isolation405



        Testing and data


        test_press(X,Y)   equation(X,E,U), solve_equation(E,U,Y).


        equation(1,cos(x)(1-2sin(x))=0,x).


        equation(2,x"2-3x+2=0,x).


        equation(3,2"(2x)-52"(x+1)+16=0,x).



        Program 23.1  (Continued)



        solve_equation(AB=0,X,Solution)  


            factorize(AB,X,Factorsn[ ]),


            remove_duplicates(Factors,Factors1),


            solve_factors(Factors1,X,Solution).



The top-level clause in Program 23.1 has a cut as the first goal in the body. T*
 *his


is a green cut: none of the other methods depend on the success or failure of


factorization. In general, we omit green cuts from clauses we describe in the t*
 *ext.



23.3   Isolation



    A useful concept to locate and manipulate the single occurrence of the un-


known is its position. The position of a subterm in a term is a list of argument


numbers specifying where it appears.  Consider the equation cos(x) = 0.  The


term cos(x) containing x is the first argument of the equation, and x is the fi*
 *rst


(and only) argument of cos(x). The position of x in cos(x) = 0 is therefore [1,*
 *1].




406   An Equation Solver                                        23.3



               Figure 23.2:  Position of subterms in terms



This is indicated in the diagram in Figure 23.2. The figure also shows the posi*
 *tion


of x in 1  2  sin(x) = 0 which is [1,2,2,1].


    The clause defining the method of isolation is



        solve_equation(Equation,X,Solution)  


            single_occurrence(X,Equation),


            position(X,Equation,[SidejPosition]),


            maneuver_sides(Side,Equation,Equation1),


            isolate(Position,Equation1,Solution).



The condition characterizing when isolation is applicable is that there be a si*
 *ngle


occurrence of the unknown X in the equation, checked by single_occurrence.


The method calculates the position of X with the predicate position. The iso-


lation of X then proceeds in two stages.  First, maneuver_sides ensures that X


appears on the left-hand side of the equation, and second, isolate makes it the




23.3                                                    Isolation407



subject of the formula.


    It is useful to define single_occurrence in terms of the more general pred-


icate occurrence(Subterm,Term,N), which counts the number of times N that


Subterm occurs in the term Term. Both occurrence and position are typical


structure inspection predicates.  Both are posed as exercises at the end of Sec-


tion 9.2. Code for them appears in the utilities section of Program 23.1.


    The predicate maneuver_sides(N,Equation,Equation1) consists of two


facts:


        maneuver_sides(1,Lhs = Rhs,Lhs = Rhs).


        maneuver_sides(2,Lhs = Rhs,Rhs = Lhs).



Its effect is to ensure that the unknown appears on the left-hand side of Equa-


tion1. The first argument N, the head of the position list, indicates the side *
 *of


the equation in which the unknown appears. A 1 means the left-hand side, and


the equation is left intact. A 2 means the right-hand side, and so the sides of*
 * the


equation are swapped.


    The transformation of the equation is done by isolate/3.  It repeatedly


applies rewrite rules until the position list is exhausted:


        isolate([NjPosition],Equation,IsolatedEquation)  


            isolax(N,Equation,Equation1),


            isolate(Position,Equation1,IsolatedEquation).


        isolate([ ],Equation,Equation).



The rewrite rules,  or isolation axioms,  are specified by the predicate iso-




408   An Equation Solver                                        23.3



lax(N,Equation,Equation1).   Let us consider an example used in solving


1  2  sin(x) = 0.  An equivalence transformation on equations is adding the


same quantity to both sides of an equation. We show its translation into an iso-


lax axiom for manipulating equations of the form uv = w. Note that rules need


only simplify the left-hand side of equations, since the unknown is guaranteed *
 *to


be on that side.


    Two rules are necessary to cover the two cases whether the first or second


argument of u  v contains the unknown. The term u  v = w can be rewritten


to either u = w + v or v = u  w. The first argument of isolax specifies which


argument of the sum contains the unknown.  The Prolog equivalent of the two


rewrite rules is then



        isolax(1,Term1-Term2 = Rhs,Term1 = Rhs+Term2).


        isolax(2,Term1-Term2 = Rhs,Term2 = Term1-Rhs).



Other isolation axioms are more complicated. Consider simplifying a product on


the left-hand side of an equation. One of the expected rules would be



        isolax(1,Term1Term2 = Rhs,Term1 = Rhs/Term2).



If Term2 equals zero, however, the rewriting is invalid. A test is therefore ad*
 *ded


that prevents the axioms for multiplication being applied if the term by which *
 *it


divides is 0. For example,



        isolax(1,Term1Term2 = Rhs,Term1 = Rhs/Term2)   Term2 6= 0.



    Isolation axioms for trigonometric functions illustrate another possibility*
 * that




23.3                                                    Isolation409



must be catered for | multiple solutions. An equation such as sin(x) = 1=2 that


is reached in our example has two solutions between 0 and 2  ss. The alternative


solutions are handled by having separate isolax axioms:



        isolax(1,sin(U) = V,U = arcsin(V)).


        isolax(1,sin(U) = V,U = ss - arcsin(V)).



    In fact, the equation has a more general solution. Integers of the form 2nss


can be added to either solution for arbitrary values of n. The decision whether


a particular or general solution is desired depends on context and on semantic


information independent of the equation solver.


    Further examples of isolation axioms are given in the complete equation


solver, Program 23.1.


    The code described so far is sufficient to solve the first equation in Fig-


ure 23.1, cos(x)(12sin(x)) = 0. There are four answers arccos(0),  arccos(0),


arcsin((1  0)=2), ss  arcsin((1  0)=2).  Each can be simplified, for example,


arcsin((1  0)=2) to ss=6, but will not be unless the expression is explicitly e*
 *valu-


ated.


    The usefulness of an equation solver depends on how well it can perform


such simplification, even though simplification is not strictly part of the equ*
 *ation-


solving task. Writing an expression simplifier is nontrivial, however. It is un*
 *de-


cidable whether two expressions are equivalent in general. Some simple identiti*
 *es


of algebra can be easily incorporated, for example, rewriting 0 + u to u. Choos*
 *ing


between other preferred forms, e.g., (1 + x)3 and 1 + 3  x + 3  x2 + x3, depends




410   An Equation Solver                                        23.3



on context.



23.4   Polynomial



    Polynomial equations are solved by a polynomial equation solver, applying


various polynomial methods. Both sides of the equation are checked as to whether


they are polynomials in the unknown. If the checks are successful, the equation


is converted to a polynomial normal form by polynomial_normal_form, and the


polynomial equation solver solve_polynomial_equation is invoked:


        solve_equation(Lhs=Rhs,X,Solution)  


            polynomial(Lhs,X),


            polynomial(Rhs,X),


            polynomial_normal_form(Lhs-Rhs,X,PolyForm),


            solve_polynomial_equation(PolyForm,X,Solution).



    The polynomial normal form is a list of tuples of the form (Ai,Ni), where Ai


is the coefficient of X Ni, which is necessarily nonzero. The tuples are sorted*
 * into


strictly decreasing order of Ni; for each degree there is at most one tuple.  F*
 *or


example, the list [(1; 2); (3; 1); (2; 0)] is the normal form for x2  3  x + 2.*
 * The


leading term of the polynomial is the head of the list. The classic algorithms *
 *for


handling polynomials are applicable to equations in normal form. Reduction to


polynomial normal form occurs in two stages:


        polynomial_normal_form(Polynomial,X,NormalForm)  


            polynomial_form(Polynomial,X,PolyForm),




23.4                                                  Polynomial411



            remove_zero_terms(PolyForm,NormalForm).



    The predicate polynomial_form(X,Polynomial,PolyForm) decomposes the


polynomial.  PolyForm is a sorted list of coefficient-degree tuples, where tupl*
 *es


with zero coefficients may occur.


    It is convenient for many of the polynomial methods to assume that all the


terms in the polynomial form have nonzero coefficients. Therefore the final step


of polynomial_normal_form is removing those terms whose coefficients are zero.


This is achieved by a simple recursive procedure remove_zero_terms.


    The code for polynomial_form directly echoes the code for polynomial. For


each clause used in the parsing process, there is a corresponding clause giving*
 * the


resultant polynomial. For example, the polynomial form of a term xn is [(1; n)],


which is expressed in the clause



        polynomial_form(X"N,X,[(1,N)]).



    The recursive clauses for polynomial_form manipulate the polynomials in


order to preserve the polynomial form. Consider the clause



        polynomial_form(Poly1+Poly2,X,PolyForm)  


            polynomial_form(Poly1,X,PolyForm1),


            polynomial_form(Poly2,X,PolyForm2),


            add_polynomials(PolyForm1,PolyForm2,PolyForm).



The procedure add_polynomials contains an algorithm for adding polynomials in


normal form. The code is a straightforward list of the possibilities that can a*
 *rise:




412   An Equation Solver                                        23.4



    add_polynomials([ ],Poly,Poly).


    add_polynomials(Poly,[ ],Poly).


    add_polynomials([(Ai,Ni)jPoly1],[(Aj,Nj)jPoly2],[(Ai,Ni)jPoly])  


        Ni > Nj, add_polynomials(Poly1,[(Aj,Nj)jPoly2],Poly).


    add_polynomials([(Ai,Ni)jPoly1],[(Aj,Nj)jPoly2],[(A,Ni)jPoly])  


        Ni =:= Nj, A is Ai+Aj, add_polynomials(Poly1,Poly2,Poly).


    add_polynomials([(Ai,Ni)jPoly1],[(Aj,Nj)jPoly2],[(Aj,Nj)jPoly])  


        Ni < Nj, add_polynomials([(Ai,Ni)jPoly1],Poly2,Poly).



    Similarly, the procedures subtract_polynomials, multiply_polynomials,


and binomial are algorithms for subtracting, multiplying, and binomially expand-


ing polynomials in normal form to produce results in normal form. The subsidiary


predicate multiply_single(Poly1,Monomial,Poly2) multiplies a polynomial by


a monomial (C,N ) to produce a new polynomial.


    Once the polynomial is in normal form, the polynomial equation solver is


invoked. The structure of the polynomial solver follows the structure of the ov*
 *erall


equation solver. The solver is a collection of methods that are tried in order *
 *to


see which is applicable and can be used to solve the equation.  The predicate


solve_polynomial_equation is the analogous relation to solve_equation.


    The second equation in Figure 23.1 is quadratic and can be solved with


the standard formula.  The equation solver mirrors the human method.  The


polynomial is identified as being suitable for the quadratic method by checking


(with quadratic) if the leading term in the polynomial is of second degree. Sin*
 *ce


zero terms have been removed in putting the polynomial into its normal form,




23.5                                              Homogenization413



pad puts them back if necessary. The next two steps are familiar: calculating t*
 *he


discriminant, and returning the roots according to the value of the discriminan*
 *t.


Again multiple solutions are indicated by having multiple possibilities:



        solve_polynomial_equation(Poly,X,Solution)  


            quadratic(Poly),


            pad(Poly,[(A,2),(B,1),(C,0)]),


            discriminant(A,B,C,Discriminant),


            root(X,A,B,C,Discriminant,Solution).


        discriminant(A,B,C,D)   D is (BB - 4AC).


        root(X,A,B,C,0,X= -B/(2A)).


        root(X,A,B,C,D,X= (-B+sqrt(D))/(2A))   D > 0.


        root(X,A,B,C,D,X= (-B-sqrt(D))/(2A))   D > 0.



    Other clauses for solve_polynomial_equation constitute separate methods


for solving different polynomial equations.  Linear equations are solved with a


simple formula. In PRESS, cubic equations are handled by guessing a root and


then factoring, reducing the equation to a quadratic. Other tricks recognize ob*
 *vi-


ous factors, or that quartic equations missing a cubic and a linear term are re*
 *ally


disguised quadratics.



23.5   Homogenization



    The top-level clause for homogenization reflects the transformation of the




414   An Equation Solver                                        23.5



original equation into a new equation in a new unknown, which is recursively


solved; its solution is obtained for the original unknown:



        solve_equation(Equation,X,Solution)  


            homogenize(Equation,X,Equation1,X1),


            solve_equation(Equation1,X1,Solution1),


            solve_equation(Solution1,X,Solution).



    The code for homogenize/4 implements the four stages of homogenization,


described in Section 23.1. The offenders set is calculated by offenders/3, which


checks that there are multiple offenders. If there is only a single offender, h*
 *omog-


enization will not be useful:



        homogenize(Equation,X,Equation1,X1)  


            offenders(Equation,X,Offenders),


            reduced_term(X,Offenders,Type,X1),


            rewrite(Offenders,Type,X1,Substitutions),


            substitute(Equation,Substitutions,Equation1).



    The predicate reduced_term/4 finds a reduced term, that is, a candidate


for the new unknown. In order to structure the search for the reduced term, the


equation is classified into a type. This type is used in the next stage to find*
 * rewrite


rules expressing each element of the offenders set as an appropriate function of


the reduced term.  The type of the example equation is exponential.  PRESS


encodes a lot of heuristic knowledge about finding a suitable reduced term. The


heuristics depend on the type of the terms appearing in the offenders set. To a*
 *id




23.5                                              Homogenization415



the structuring (and retrieval) of knowledge, finding a reduced term proceeds in


two stages | classifying the type of the offenders set, and finding a reduced t*
 *erm


of that type:


        reduced_term(X,Offenders,Type,X1)  


            classify(Offenders,X,Type),


            candidate(Type,Offenders,X,X1).



    We look at the set of rules appropriate to our particular equation.  The


offenders set is of exponential type because all the elements in the offenders *
 *set


have the form AB , where A does not contain the unknown but B does. Standard


recursive procedures check that this is true.


    The heuristic used to select the reduced term in this example is that if all


the bases are the same, A, and each exponent is a polynomial in the unknown,


X , then a suitable reduced term is AX :


        candidate(exponential,Offenders,X,A"X)  


            base(Offenders,A), polynomial_exponents(Offenders,X).



The straightforward code for base and polynomial_exponents is in the complete


program.  The heuristics in PRESS are better developed than the ones shown


here. For example, the greatest common divisor of all the leading terms of the


polynomials is calculated and used to choose the reduced term.


    The next step is checking whether each member of the offenders set can


be rewritten in terms of the reduced term candidate.  This involves finding an


appropriate rule. The collection of clauses for homogenize_axiom constitute the




416   An Equation Solver                                        23.5



possibly applicable rewrite rules. In other words, relevant rules must be speci*
 *fied


in advance. The applicable rules in this case are


        homogenize_axiom(exponential,A"(NX),A"X,(A"X)"N).


        homogenize_axiom(exponential,A"(X+B),A"X,A"BA"X).



    Substituting the term in the equation echoes the parsing process used by of-


fenders as each part of the equation is checked to see whether it is the approp*
 *riate


term to rewrite.



Exercises for Chapter 23



(i) Add isolation axioms to Program 23.1 to handle quotients on the left-hand


    side of the equation. Solve the equation x=2 = 5.


(ii)Add to the polynomial equation solver the ability to solve disguised linear


    and disguised quadratic equations. Solve the equations 2  x3  8 = x3, and


    x4  5  x2 + 6 = 0.


(iii)The equation cos(2  x)  sin(x) = 0 can be solved as a quadratic equation


    in sin(x) by applying the rewrite rule cos(2  x) = 1  2  sin2(x).  Add


    clauses to Program 23.1 to solve this equation. You will need to add rules *
 *for


    identifying terms of type trigonometric, heuristics for finding trigonometr*
 *ic


    reduced terms, and appropriate homogenization axioms.


(iv)Rewrite the predicate free_of(Term,X) so that it fails as soon as it finds *
 *an


    occurrence of X in Term.


(v) Modify Program 23.1 so that it solves simple simultaneous equations.




23.6                                                 Background 417



23.6   Background



    Symbolic manipulation was an early application area for Prolog. Early ex-


amples are programs for symbolic integration (Bergman and Kanoui, 1973) and


for proving theorems in geometry (Welham, 1976).



    The PRESS program, from which Program 23.1 is adapted, owes a debt


to many people.  The original version was written by Bob Welham.  Many of


the researchers in the mathematical reasoning group working with Alan Bundy


at the University of Edinburgh subsequently tinkered with the code. Published


descriptions of the program appear in Bundy and Welham (1981), Sterling et


al. (1982), and Silver (1986).  The last reference has a detailed discussion of


homogenization.



    PRESS includes various modules, not discussed in this chapter, that are


interesting in their own right:  for example, a package for interval arithmetic


(Bundy, 1984), an infinite precision rational arithmetic package developed by


Richard O'Keefe, and an expression simplifier based on difference-structures as


described in Section 15.2, developed by Lawrence Byrd. The successful integrati*
 *on


of all these modules is strong evidence for the practicality of Prolog for large


programming projects.



    The development of PRESS showed up classic points of software engineering.


For example, at one stage the program was being tuned prior to publishing some


statistics. Profiling was done on the program, which showed that the predicate


most commonly called was free_of. Rewriting it as suggested in Exercise 23(iv)




418   An Equation Solver                                        23.6



resulted in a speedup of 35 percent in the performance of PRESS.


    Program 23.1 is a considerably cleaned-up version of PRESS. Tidying the


code enabled further research. Program 23.1 was easily translated to other logic


programming languages, Concurrent Prolog and FCP (Sterling and Codish, 1986).


Making the conditions when methods were used more explicit enabled the writing


of a program to learn new equation-solving methods from examples (Silver, 1986).
