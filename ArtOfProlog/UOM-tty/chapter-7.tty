



                                                   Chapter  7



                                        Programming


                                      in  Pure  Prolog



   A major aim of logic programming is to enable the programmer to program


at a higher level.  Ideally one should write axioms that define the desired rel*
 *a-


tions, maintaining ignorance of the way they are going to be used by the execu-


tion mechanism. Current logic programming languages, Prolog in particular, are


still far away from allowing this ideal of declarative programming. The specifi*
 *c,


well-defined choices of how their execution mechanisms approximate the abstract


interpreter cannot be ignored. Effective logic programming requires knowing and


utilizing these choices.



   This chapter discusses the consequences of Prolog's execution model for the


logic programmer.  New aspects of the programming task are introduced.  Not


only must programmers come up with a correct and complete axiomatization of


a relation but they must also consider its execution according to the model.




108   Programming in Pure Prolog                                  7.1



7.1   Rule Order



   Two syntactic issues, irrelevant for logic programs, are important to consid*
 *er


when composing Prolog programs. The rule order, or clause order, of clauses in


each procedure must be decided. Also the goal order of goals in the bodies of e*
 *ach


clause must be determined. The consequences of these decisions can be immense.


There can be orders of magnitude of difference in efficiency in the performance*
 * of


Prolog programs. In extreme though quite common cases, correct logic programs


will fail to give solutions because of nontermination.



   The rule order determines the order in which solutions are found.



   Changing the order of rules in a procedure permutes the branches in any


search tree for a goal using that procedure. The search tree is traversed depth-


first. So permuting the branches causes a different order of traversal of the s*
 *earch


tree, and a different order of finding solutions.  The effect is clearly seen w*
 *hen


using facts to answer an existential query.  With our biblical database and a


query such as father(X,Y)?, changing the order of facts will change the order of


solutions found by Prolog. Deciding how to order facts is not very important.



   The order of solutions of queries solved by recursive programs is also de-


termined by the clause order. Consider Program 5.1, a simple biblical database


together with a program for the relationship ancestor, repeated here as Pro-


gram 7.1.



   For the query ancestor(terach,X)? with respect to Program 7.1, the solu-


tions will be given in the order, X=abraham, X=isaac, X=jacob, and X=benjamin.




7.1                                                    Rule Order 109


       parent(terach,abraham).     parent(abraham,isaac).


       parent(isaac,jacob).        parent(jacob,benjamin).


       ancestor(X,Y)   parent(X,Y).


       ancestor(X,Z)   parent(X,Y), ancestor(Y,Z).



       Program 7.1:  Yet another family example



If the rules defining ancestor are swapped, the solutions will appear in a diff*
 *erent


order, namely, X=benjamin, X=jacob, X=isaac, and X=abraham.


   The different order of ancestor clauses changes the order of searching the


implicit family tree. In one order, Prolog outputs solutions as it goes along. *
 *With


the other order, Prolog travels to the end of the family tree and gives solutio*
 *ns


on the way back. The desired order of solutions is determined by the applicatio*
 *n,


and the rule order of ancestor is chosen accordingly.


   Changing the order of clauses for the member predicate (Program 3.12) also


changes the order of search. As written, the program searches the list until the


desired element is found. If the order of the clauses is reversed, the program *
 *always


searches to the end of the list.  The order of solutions will also be affected,*
 * for


example, responding to the query member(X,[1,2,3])?. In the standard order,


the order of solutions is intuitive: X=1, X=2, X=3.  With the rules swapped, the


order is X=3, X=2, X=1. The order of Program 3.12 is more intuitive and hence


preferable.


   When the search tree for a given goal has an infinite branch, the order of


clauses can determine if any solutions are given at all. Consider the query ap-




110   Programming in Pure Prolog                                  7.1



pend(Xs,[c,d],Ys)? with respect to append. As can be seen from the search


tree in Figure 5.4, no solutions would be given. If, however, the append fact a*
 *p-


peared before the append rule, an infinite number of pairs Xs,Ys satisfying the


query would be given.



   There is no consensus as to how to order the clauses of a Prolog procedure.


Clearly, the standard dictated in more conventional languages, of testing for t*
 *he


termination condition before proceeding with the iteration or recursion is not


mandatory in Prolog. This is demonstrated in Program 3.15 for append as well as


in other programs in this book. The reason is that the recursive or iterative c*
 *lause


tests its applicability by unification. This test is done explicitly and indepe*
 *ndently


of the other clauses in the procedure.



   Clause order is more important for general Prolog programs than it is for


pure Prolog programs. Other control features, notably the cut to be discussed in


Chapter 11, depend significantly on the clause order. When such constructs are


used, clauses lose their independence and modularity, and clause order becomes


significant.



   In this chapter, for the most part, the convention that the recursive clauses


precede the base clauses is adopted.



Exercises for Section 7.1



(i)Verify the order of solutions for the query ancestor(abraham,X)? with re-


   spect to Program 7.1, and its variant with different rule order for ancestor,




7.2                                                   Termination 111



   claimed in the text.


(ii)What is the order of solutions for the query ancestor(X,benjamin)? with


   respect to Program 7.1? What if the rule order for ancestor were swapped?



7.2   Termination



   Prolog's depth-first traversal of search trees has a serious problem.  If the


search tree of a goal with respect to a program contains an infinite branch, the


computation will not terminate. Prolog may fail to find a solution to a goal, e*
 *ven


though the goal has a finite computation.


   Nontermination arises with recursive rules.  Consider adding a relationship


married(Male,Female) to our database of family relationships.  A sample fact


from the biblical situation is married(abraham,sarah).  A user querying the


married relationship should not care whether males or females are first, as the


relationship is commutative. The \obvious" way of overcoming the commutativity


is adding a recursive rule married(X,Y)   married(Y,X). If this is added to the


program, no computation involving married would ever terminate. For example,


the trace of the query married(abraham,sarah)? is given in Figure 7.1.


   Recursive rules that have the recursive goal as the first goal in the body a*
 *re


known as left recursive rules. The problematic married axiom is an example. Left


recursive rules are inherently troublesome in Prolog. They cause nonterminating


computations if called with inappropriate arguments.


   The best solution to the problem of left recursion is avoidance. The married




112   Programming in Pure Prolog                                  7.2


                 married(X,Y)   married(Y,X).


                 married(abraham,sarah).


                 married(abraham,sarah)


                     married(sarah,abraham)


                         married(abraham,sarah)


                            married(sarah,abraham)


                                : : :


               Figure 7.1:  A nonterminating computation



relationship used a left recursive rule to express commutativity.  Commutative


relationships are best handled differently, by defining a new predicate that ha*
 *s a


clause for each permutation of the arguments of the relationship.  For the rela-


tionship married, a new predicate, are_married(Person1,Person2), say, would


be defined using two rules:



       are_married(X,Y)   married(X,Y).


       are_married(X,Y)   married(Y,X).



Unfortunately, it is not generally possible to remove all occurrences of left r*
 *ecur-


sion.  All the elegant minimal recursive logic programs shown in Chapter 3 are


left recursive, and can cause nontermination. However, the appropriate analysis,


using the concepts of domains and complete structures introduced in Section 5.2,


can determine which queries will terminate with respect to recursive programs.


   Let us consider an example, Program 3.15 for appending two lists.  The


program for append is everywhere terminating for the set of goals whose first




7.2                                                   Termination 113



and/or last argument is a complete list. Any append query whose first argument


is a complete list will terminate. Similarly, all queries where the third argum*
 *ent is


a complete list will terminate. The program will also terminate if the first an*
 *d/or


third argument is a ground term that is not a list. The behavior of append is b*
 *est


summed up by considering the queries that do not terminate, namely, when both


the first and third arguments are incomplete lists that are unifiable.


   The condition for when a query to Program 3.12 for member terminates is


also stated in terms of incomplete lists. A query does not terminate if the sec*
 *ond


argument is an incomplete list. If the second argument of a query to member is a


complete list, the query terminates.


   Another guaranteed means of generating nonterminating computations, easy


to overlook, is circular definitions. Consider the pair of rules


       parent(X,Y)   child(Y,X).


       child(X,Y)   parent(Y,X).



Any computation involving parent or child, for example, parent(haran,lot)?,


will not terminate. The search tree necessarily contains an infinite branch, be*
 *cause


of the circularity.



Exercises for Section 7.2



(i)Discuss the termination behavior of both programs in Program 3.13 deter-


   mining prefixes and suffixes of lists.


(ii)Discuss the termination of Program 3.14c for sublist.




114   Programming in Pure Prolog                                  7.3



7.3   Goal Order



   Goal order is more significant than clause order.  It is the principal means


of specifying sequential flow of control in Prolog programs.  The programs for


sorting lists, e.g., Program 3.22 for quicksort, exploit goal order to indicate*
 * the


sequence of steps in the sorting algorithms.



   We first discuss goal order from the perspective of database programming.


The order of goals can affect the order of solutions. Consider the query daugh-


ter(X,haran)? with respect to a variant of Program 1.2, where the order of the


facts female(milcah) and female(yiscah) is interchanged. The two solutions


are given in the order X=milcah, X=yiscah.  If the goal order of the daughter


rule were changed to be daughter(X,Y)   female(X),father(Y,X)., the or-


der of the solutions to the query, given the same database, would be X=yiscah,


X=milcah.



   The reason that the order of goals in the body of a clause affects the order


of solutions to a query is different from the reason that the order of rules in*
 * a


procedure affects the solution order.  Changing rule order does not change the


search tree that must be traversed for a given query. The tree is just traverse*
 *d in


a different order. Changing goal order changes the search tree.



   Goal order determines the search tree.



   Goal order affects the amount of searching the program does in solving a


query by determining which search tree is traversed.  Consider the two search


trees for the query son(X,haran)?, given in Figure 5.2.  They represent two




7.3                                                    Goal Order 115



different ways of finding a solution.  In the first case, solutions are found by


searching for children of haran and checking if they are male. The second case


corresponds to the rule for son being written with the order of the goals in its


body swapped, namely, son(X,Y)   male(X), parent(Y,X). Now the query is


solved by searching through all the males in the program and checking if they a*
 *re


children of haran.  If there were many male facts in the program, more search


would be involved. For other queries, for example, son(sarah,X)?, the reverse


order has advantages. Since sarah is not male, the query would fail more quickl*
 *y.


   The optimal goal order of Prolog programs varies with different uses. Con-


sider the definition of grandparent. There are two possible rules:


       grandparent(X,Z)   parent(X,Y), parent(Y,Z).


       grandparent(X,Z)   parent(Y,Z), parent(X,Y).



If you wish to find someone's grandson with the grandfather relationship with


a query such as grandparent(abraham,X)?, the first of the rules searches more


directly.  If looking for someone's grandparent with a query such as grandpar-


ent(X,isaac)?, the second rule finds the solution more directly. If efficiency *
 *is


important, then it is advisable to have two distinct relationships, grandparent


and grandchild, to be used appropriately at the user's discretion.


   In contrast to rule order, goal order can determine whether computations


terminate. Consider the recursive rule for ancestor:


       ancestor(X,Y)   parent(X,Z), ancestor(Z,Y).



If the goals in the body are swapped, the ancestor program becomes left recur-




116   Programming in Pure Prolog                                  7.3



sive, and all Prolog computations with ancestor are nonterminating.


   The goal order is also important in the recursive clause of the quicksort


algorithm in Program 3.22:


       quicksort([XjXs],Ys)  


           partition(Xs,X,Littles,Bigs),


           quicksort(Littles,Ls),


           quicksort(Bigs,Bs),


           append(Ls,[XjBs],Ys).



The list should be partitioned into its two smaller pieces before recursively s*
 *orting


the pieces.  If, for example, the order of the partition goal and the recursive


sorting goal is swapped, no computations terminate.


   We next consider Program 3.16a for reversing a list:


       reverse([ ],[ ]).


       reverse([XjXs],Zs)   reverse(Xs,Ys), append(Ys,[X],Zs).



The goal order is significant.  As written, the program terminates with goals


where the first argument is a complete list. Goals where the first argument is *
 *an


incomplete list give nonterminating computations.  If the goals in the recursive


rule are swapped, the determining factor of the termination of reverse goals is


the second argument. Calls to reverse with the second argument a complete list


terminate. They do not terminate if the second argument is an incomplete list.


   A subtler example comes from the definition of the predicate sublist in


terms of two append goals, specifying the sublist as a suffix of a prefix, as g*
 *iven in




7.3                                                    Goal Order 117



Program 3.14e. Consider the query sublist([2,3],[1,2,3,4])? with respect


to the program. The query is reduced to append(AsXs,Bs,[1,2,3,4]),append(


As,[2,3],AsXs)?. This has a finite search tree, and the initial query succeeds.


If Program 3.14e had its goals reversed, the initial query would be reduced to


append(As,[2,3],AsXs),append(AsXs,Bs,[1,2,3,4])?.  This leads to a non-


terminating computation because of the first goal, as illustrated in Figure 5.4.


   A useful heuristic for goal order can be given for recursive programs with


tests such as arithmetic comparisons, or determining whether two constants are


different.  The heuristic is to place the tests as early as possible.  An examp*
 *le


comes in the program for partition, which is part of Program 3.22. The first


recursive rule is



   partition([XjXs],Y,[XjLs],Bs)   X  Y, partition(Xs,Y,Ls,Bs).



The test X  Y should go before the recursive call. This leads to a smaller sear*
 *ch


tree.


   In Prolog programming (in contrast, perhaps, to life in general) our goal is


to fail as quickly as possible. Failing early prunes the search tree and brings*
 * us


to the right solution sooner.



Exercises for Section 7.3



(i)Consider the goal order for Program 3.14e defining a sublist of a list as a


   suffix of a prefix.  Why is the order of the append goals in Program 3.14e


   preferable? (Hint:  Consider the query sublist(Xs,[a,b,c])?.)




118   Programming in Pure Prolog                                  7.3



(ii)Discuss the clause order, goal order, and termination behavior for substi-


   tute, posed as Exercise 3.3(i).



7.4   Redundant Solutions



   An important issue when composing Prolog programs, irrelevant for logic


programs, is the redundancy of solutions to queries. The meaning of a logic pro-


gram is the set of ground goals deducible from it. No distinction is made betwe*
 *en


whether a goal in the meaning could be deduced uniquely from the program, or


whether it could be deduced in several distinct ways. This distinction is impor*
 *tant


for Prolog when considering the efficiency of searching for solutions. Each pos*
 *sible


deduction means an extra branch in the search tree. The bigger the search tree,


the longer a computation will take. It is desirable in general to keep the size*
 * of


the search tree as small as possible.


   Having a redundant program may cause, in an extreme case, exponential


increase in runtime, in the event of backtracking.  If a conjunction of n goals


is solved, and each goal has one redundant solution, then in the event of back-


tracking, the conjunction may generate 2n solutions, thus possibly changing a


polynomial-time program (or even a linear one) to be exponential.


   One way for redundancy to occur in Prolog programs is by covering the same


case with several rules. Consider the following two clauses defining the relati*
 *on


minimum.



       minimum(X,Y,X)   X  Y.




7.4                                            Redundant Solutions119



       minimum(X,Y,Y)   Y  X.



The query minimum(2,2,M)? with respect to these two clauses has a unique so-


lution M=2, which is given twice; one is redundant.


   Careful specification of the cases can avoid the problem. The second clause


can be changed to



       minimum(X,Y,Y)   Y < X.



Now only the first rule covers the case when the two numbers have equal values.


   Similar care is necessary with the definition of partition as part of Pro-


gram 3.22 for quicksort.  The programmer must ensure that only one of the


recursive clauses for partition covers the case when the number being compared


is the same as the number being used to split the list.


   Another way redundancy appears in programs is by having too many spe-


cial cases.  Some of these can be motivated by efficiency.  An extra fact can be


added to Program 3.15 for append, namely, append(Xs,[ ],Xs), to save recur-


sive computations when the second argument is an empty list. In order to remove


redundancy, each of the other clauses for append would have to cover only lists


with at least one element as their second argument.


   We illustrate these points when composing Program 7.2 for the relation


merge(Xs,Ys,Zs), which is true if Xs and Ys are lists of integers sorted in as-


cending order and Zs is the ordered list resulting from merging them.


   There are three separate recursive clauses.  They cover the three possible




120   Programming in Pure Prolog                                  7.4


       merge(Xs,Ys,Zs)  


           Zs is an ordered list of integers obtained from


           merging the ordered lists of integers Xs and Ys.


       merge([XjXs],[YjYs],[XjZs])  


           X < Y, merge(Xs,[YjYs],Zs).


       merge([XjXs],[YjYs],[X,XjZs])  


           X =:= Y, merge(Xs,Ys,Zs).


       merge([XjXs],[YjYs],[YjZs])  


           X > Y, merge([XjXs],Ys,Zs).


       merge([ ],[XjXs],[XjXs]).


       merge(Xs,[ ],Xs).



       Program 7.2:  Merging ordered lists



cases: when the head of the first list is less than, equal to, or greater than *
 *the


head of the second list. We discuss the predicates <, =:=, and > in Chapter 8.


Two cases are needed when the elements in either list have been exhausted. Note


that we have been careful that the goal merge([ ],[ ],[ ]) is covered by only


one fact, the bottom one.



   Redundant computations occur when using member to find whether a partic-


ular element occurs in a particular list, and there are multiple occurrences of*
 * the


particular element being checked for in the list. For example, the search tree *
 *for


the query member(a,[a,b,a,c]) would have two success nodes.



   The redundancy of previous programs was removed by a careful consideration




7.5                              Recursive Programming in Pure Prolog121



       member_check(X,Xs)  


           X  is a member of the list Xs.


       member_check(X,[XjXs]).


       member_check(X,[YjYs])   X 6= Y, member_check(X,Ys).



       Program 7.3:  Checking for list membership



of the logic. In this case, the member program is correct. If we want a differe*
 *nt


behavior, the solution is to compose a modified version of member.


   Program 7.3 defines the relation member_check(X,Xs) which checks whether


an element X is a member of a list Xs. The program is a variant of Program 3.12


for member that adds a test to the recursive clause.  It has the same meaning


but, as a Prolog program, it behaves differently. Figure 7.2 shows the differen*
 *ce


between the search trees for the identical query to the two programs. The left *
 *tree


is for the goal member(a,[a,b,a,c]) with respect to Program 3.12. Note there


are two success nodes. The right tree is for the goal member_check(a,[a,b,a,c])


with respect to Program 7.3. It has only one success node.


   We restrict use of Program 7.3 to queries where both arguments are ground.


This is because of the way 6= is implemented in Prolog, discussed in Section 11*
 *.3.



7.5   Recursive Programming in Pure Prolog



   Lists are a very useful data structure for many applications written in Prol*
 *og.


In this section, we revise several logic programs of Sections 3.2 and 3.3 conce*
 *rned




122   Programming in Pure Prolog                                  7.5



     member(a,[a,b,a,c])           member_check(a,[a,b,a,c])



   true  member(a,[b,a,c])    true  a6=a, member_check(a,[b,a,c])



       member(a,[a,c])



     true  member(a,[c])



        member(a,[ ])


                    Figure 7.2:  Variant search trees



with list processing. The chosen clause and goal orders are explained, and their


termination behavior presented. The section also discusses some new examples.


Their properties are analyzed, and a reconstruction offered of how they are com-


posed.


   Programs 3.12 and 3.15for member and append, respectively, are correct Pro-


log programs as written. They are both minimal recursive programs, so there is *
 *no


issue of goal order. They are in their preferred clause order, the reasons for *
 *which


have been discussed earlier in this chapter. The termination of the programs was


discussed in Section 7.2.


   Program 3.19 for select is analogous to the program for member:


       select(X,[XjXs],Xs).


       select(X,[YjYs],[YjZs])   select(X,Ys,Zs).



The analysis of select is similar to the analysis of member. There is no issue *
 *of


goal order because the program is minimal recursive. The clause order is chosen*
 * to




7.5                              Recursive Programming in Pure Prolog123



reflect the intuitive order of solutions to queries such as select(X,[a,b,c],Xs*
 *),


namely, fX=a,Xs=[b,c]g,fX=b,Xs=[a,c]g,fX=c,Xs=[a,b]g. The first solution


is the result of choosing the first element, and so forth. The program terminat*
 *es


unless both the second and third arguments are incomplete lists.


   A variant of select is obtained by adding the test X 6= Y in the recursive


clause. As before, we assume that 6= is only defined for ground arguments. The


variant is given as Program 7.4 defining the relation select_first(X,Xs,Ys).


Programs 3.12 and 7.3 defining member and member_check have the same mean-


ing. Program 7.4, in contrast, has a different meaning from Program 3.19. The


goal select(a,[a,b,a,c],[a,b,c]) is in the meaning of select, whereas se-


lect_first(a,[a,b,a,c],[a,b,c]) is not in the meaning of select_first.

       select_first(X,Xs,Ys)  


           Ys is the list obtained by removing the


           first occurrence of X  from the list Xs.


       select_first(X,[XjXs],Xs).


       select_first(X,[YjYs],[YjZs])  


           X 6= Y, select_first(X,Ys,Zs).



       Program 7.4:  Selecting the first occurrence of an element from a list



   The next program considered is Program 3.20 for permutation. The order of


clauses, analogously to the clause order for append, reflects the more likely m*
 *ode


of use:


   permutation(Xs,[XjYs])   select(X,Xs,Zs), permutation(Zs,Ys).




124   Programming in Pure Prolog                                  7.5



   permutation([ ],[ ]).



The goal order and the termination behavior of permutation are closely related.


Computations of permutation goals where the first argument is a complete list


will terminate. The query calls select with its second argument a complete list,


which terminates generating a complete list as its third argument.  Thus there


is a complete list for the recursive permutation goal.  If the first argument is


an incomplete list, the permutation query will not terminate, because it calls a


select goal that will not terminate.  If the order of the goals in the recursive


rule for permutation is swapped, the second argument of a permutation query


becomes the significant one for determining termination.  If it is an incomplete


list, the computation will not terminate; otherwise it will.


   A useful predicate using 6= is nonmember(X,Ys) which is true if X is not a


member of a list Ys. Declaratively the definition is straightforward: An element


is a nonmember of a list if it is not the head and is a nonmember of the tail. *
 *The


base case is that any element is a nonmember of the empty list. This program is


given as Program 7.5.

       nonmember(X,Xs)  


           X  is not a member of the list Xs.


       nonmember(X,[YjYs])   X 6= Y, nonmember(X,Ys).


       nonmember(X,[ ]).



       Program 7.5:  Nonmembership of a list



   Because of the use of 6=, nonmember is restricted to ground instances. This *
 *is




7.5                              Recursive Programming in Pure Prolog125



sensible intuitively. There are arbitrarily many elements that are not elements*
 * of


a given list, and also arbitrarily many lists not containing a given element. T*
 *hus


the behavior of Program 7.5 with respect to these queries is largely irrelevant.



   The clause order of nonmember follows the convention of the recursive clause


preceding the fact. The goal order uses the heuristic of putting the test before


the recursive goal.



   We reconstruct the composition of two programs concerned with the subset


relation. Program 7.6 defines a relation based on Program 3.12 for member, and


Program 7.7 defines a relation based on Program 3.19 for select. Both consider


the occurrences of the elements of one list in a second list.



   Program 7.6 defining members(Xs,Ys) ignores the multiplicity of elements


in the lists.  For example, members([b,b],[a,b,c]) is in the meaning of the


program.  There are two occurrences of b in the first list, but only one in the


second.



   Program 7.6 is also restrictive with respect to termination. If either the f*
 *irst


or the second argument of a members query is an incomplete list, the program wi*
 *ll


not terminate. The second argument must be a complete list because of the call


to member, while the first argument must also be complete, since that is provid*
 *ing


the recursive control.  The query members(Xs,[1,2,3])?  asking for subsets of


a given set does not terminate. Since multiple copies of elements are allowed in


Xs, there are an infinite number of solutions, and hence the query should not


terminate.




126   Programming in Pure Prolog                                  7.5



       members(Xs,Ys)  


           Each element of the list Xs is a member of the list Ys.


       members([XjXs],Ys)   member(X,Ys), members(Xs,Ys).


       members([ ],Ys).



       Program 7.6:  Testing for a subset



       selects(Xs,Ys)  


           The list Xs is a subset of the list Ys.


       selects([XjXs],Ys)   select(X,Ys,Ys1), selects(Xs,Ys1).


       selects([ ],Ys).


       select(X,Ys,Zs)   See Program 3.19.



       Program 7.7:  Testing for a subset



   Both these limitations are avoided by Program 7.7. The revised relation is


selects(Xs,Ys).  Goals in the meaning of Program 7.7 have at most as many


copies of an element in the first list as appear in the second.  Related to this


property, Program 7.7 terminates whenever the second argument is a complete


list. A query such as selects(Xs,[a,b,c]) has as solution all the subsets of a


given set.



   We now consider a different example: translating a list of English words, wo*
 *rd


for word, into a list of French words. The relation is translate(Words,Mots),


where Words is a list of English words and Mots the corresponding list of




7.5                              Recursive Programming in Pure Prolog127



French words.  Program 7.8 performs the translation.  It assumes a dictio-


nary of pairs of corresponding English and French words, the relation scheme


being  dict(Word,Mot).   The  translation  is  very  naive,  ignoring  issues  *
 *of


number,  gender,  subject-verb agreement,  and so on.   Its range is solving


a query such as translate([the,dog,chases,the,cat]),X)? with solution


X=[le,chien,chasse,le,chat].  This program can be used in multiple ways.


English sentences can be translated to French, French ones to English, or two


sentences can be checked to see if they are correct mutual translations.

       translate(Words,Mots)  


           Mots is a list of French words that is the


           translation of the list of English words Words.


       translate([WordjWords],[MotjMots])  


           dict(Word,Mot), translate(Words,Mots).


       translate([ ],[ ]).


       dict(the,le).            dict(dog,chien).


       dict(chases,chasse).     dict(cat,chat).



       Program 7.8:  Translating word for word



   Program 7.8 is a typical program performing mapping, that is, converting


one list to another by applying some function to each element of the list.  The


clause order has the recursive rule(s) first, and the goal order calls dict fir*
 *st, so


as not to be left recursive.


   We conclude this section with a discussion of the use of data structures in




128   Programming in Pure Prolog                                  7.5



Prolog programs.  Data structures are handled somewhat differently in Prolog


than in conventional programming languages. Rather than having a global struc-


ture, all parts of which are accessible, the programmer specifies logical relat*
 *ions


between various substructures of the data.



   Taking a more procedural view, in order to build and modify structures,


the Prolog programmer must pass the necessary fields of the structure to sub-


procedures. These fields are used and/or acquire values during the computation.


Assignment of values to the structures happens via unification.



   Let us look more closely at a generic example | producing a single output


from some given input. Examples are the standard use of append, joining two lis*
 *ts


together to get a third, and using Program 7.8 to translate a list of English w*
 *ords


into French. The computation proceeds recursively. The initial call instantiates


the output to be an incomplete list [XjXs]. The head X is instantiated by the c*
 *all


to the procedure, often in unification with the head of the clause. The tail Xs*
 * is


progressively instantiated while solving the recursive call. The structure beco*
 *mes


fully instantiated with the solution of the base case and the termination of the


computation.



   Consider appending the list [c,d] to the list [a,b], as illustrated in Fig-


ure 4.3.  The output Ls=[a,b,c,d] is constructed in stages, as Ls=[ajZs],


Zs=[bjZs1], and finally Zs1=[c,d], when the base fact of append is used. Each


recursive call partially instantiates the originally incomplete list. Note that*
 * the


recursive calls to append do not have access to the list being computed. This is


a top-down construction of recursive structures and is typical of programming in




7.5                              Recursive Programming in Pure Prolog129



Prolog.


   The top-down construction of recursive data structures has one limitation.


Pieces of the global data structure cannot be referred to deeper in the computa-


tion. This is illustrated in a program for the relation no_doubles(XXs,Xs), whi*
 *ch


is true if Xs is a list of all the elements appearing in the list XXs with all *
 *duplicates


removed.


   Consider trying to compose no_doubles top-down. The head of the recursive


clause will be



       no_doubles([XjXs],   )  



where we need to fill in the blank.  The blank is filled by calling no_doubles


recursively on Xs with output Ys and integrating Ys with X. If X has not appear*
 *ed


in the output so far, then it should be added, and the blank will be [XjYs]. If*
 * X


has appeared, then it should not be added and the blank is Ys. This cannot be


easily said. There is no way of knowing what the output is so far.


   A program for no_doubles can be composed by thinking differently about


the problem. Instead of determining whether an element has already appeared in


the output, we can determine whether it will appear. Each element X is checked


to see if it appears again in the tail of the list Xs. If X appears, then the r*
 *esult is


Ys, the output of the recursive call to no_doubles. If X does not appear, then *
 *it is


added to the recursive result. This version of no_doubles is given as Program 7*
 *.9.


It uses Program 7.5 for nonmember.


   A problem with Program 7.9 is that the list without duplicates may not have




130   Programming in Pure Prolog                                  7.5



       no_doubles(Xs,Ys)  


           Ys is the list obtained by removing


           duplicate elements from the list Xs.


       no_doubles([XjXs],Ys)  


           member(X,Xs), no_doubles(Xs,Ys).


       no_doubles([XjXs],[XjYs])  


           nonmember(X,Xs), no_doubles(Xs,Ys).


       no_doubles([ ],[ ]).


       nonmember(X,Xs)   See Program 7.5.



       Program 7.9:  Removing duplicates from a list



the elements in the desired order.  For example, no_doubles([a,b,c,b],Xs)?


has the solution Xs=[a,c,b], where the solution Xs=[a,b,c] may be preferred.


This latter result is possible if the program is rewritten. Each element is del*
 *eted


from the remainder of the list as it is found. In terms of Program 7.9, this is*
 * done


by replacing the two recursive calls by a rule



       no_doubles([XjXs],[XjYs])  


           delete(X,Xs,Xs1), no_doubles(Xs1,Ys).



The new program builds the output top-down. However, it is inefficient for large


lists, as will be discussed in Chapter 13. Briefly, each call to delete rebuild*
 *s the


whole structure of the list.


   The alternative to building structures top-down is building them bottom-up.




7.5                              Recursive Programming in Pure Prolog131



A simple example of bottom-up construction of data structures is Program 3.16b


for reversing a list:


       reverse(Xs,Ys)   reverse(Xs,[ ],Ys).


       reverse([XjXs],Revs,Ys)   reverse(Xs,[XjRevs],Ys).


       reverse([ ],Ys,Ys).



An extra argument is added to reverse/2 and used to accumulate the values of


the reversed list as the computation proceeds. This procedure for reverse builds


the output list bottom-up rather than top-down. In the trace in Figure 7.3 solv*
 *ing


the goal reverse([a,b,c],Xs), the successive values of the middle argument of


the calls to reverse/3 [ ], [a], [b,a], and [c,b,a] represent the structure


being built.


            reverse([a,b,c],Xs)


              reverse([a,b,c],[ ],Xs)


                reverse([b,c],[a],Xs)


                  reverse([c],[b,a],Xs)


                    reverse([ ],[c,b,a],Xs)  Xs=[c,b,a]


                      true


              Figure 7.3:  Tracing a reverse computation



   A bottom-up construction of structures allows access to the partial results *
 *of


the structure during the computation.  Consider a relation nd_reverse(Xs,Ys)


combining the effects of no_doubles and reverse. The meaning of nd_reverse


is that Ys is a list of elements in Xs in reverse order and with duplicates rem*
 *oved.




132   Programming in Pure Prolog                                  7.5



Analogously to reverse, nd_reverse calls nd_reverse/3 with an extra argument


that builds the result bottom-up. This argument is checked to see whether a par-


ticular element appears, rather than checking the tail of the list as in Progra*
 *m 7.9


for no_doubles. The program is given as Program 7.10.

       nd_reverse(Xs,Ys)  


           Ys is the reversal of the list obtained by


           removing duplicate elements from the list Xs.


       nd_reverse(Xs,Ys)   nd_reverse(Xs,[ ],Ys).


       nd_reverse([XjXs],Revs,Ys)  


           member(X,Revs), nd_reverse(Xs,Revs,Ys).


       nd_reverse([XjXs],Revs,Ys)  


           nonmember(X,Revs), nd_reverse(Xs,[XjRevs],Ys).


       nd_reverse([ ],Ys,Ys).


       nonmember(X,Xs)   See Program 7.5.



       Program 7.10:  Reversing with no duplicates



   We emphasize the characteristics of bottom-up construction illustrated here.


One argument behaves as an accumulator of the final data structure. It is aug-


mented in the recursive call, so that the more complex version is in the body of


the clause rather than in its head.  This contrasts with top-down construction,


where the more complex version of the data structure being built is in the head


of the clause. Another argument is used solely for returning the output, namely,


the final value of the accumulator. It is instantiated with the satisfaction of*
 * the




7.5                              Recursive Programming in Pure Prolog133



base fact. The argument is explicitly carried unchanged in the recursive call.


   The technique of adding an accumulator to a program can be generalized.


It is used in Chapter 8 discussing Prolog programs for arithmetic. Accumulators


can also be viewed as a special case of incomplete data structures, as is discu*
 *ssed


in Chapter 15.



Exercise for Section 7.5



(i)Write Program 7.9 for no_doubles, building the structure bottom-up.




134   Programming in Pure Prolog                                  7.5



7.6   Background



   Prolog was envisaged as a first approximation to logic programming, which


would be superseded by further research.  Its control has always been acknowl-


edged as being limited and naive.  An oft-cited slogan, credited to Kowalski


(1979b), is \Algorithm = Logic + Control." The particular control provided in


pure Prolog was intended as just one solution on the path to declarative progra*
 *m-


ming and intelligent control. Time has shown otherwise. The control of Prolog


has proven adequate for a large range of applications, and the language has not


only endured but has blossomed.



   Nonetheless, logic programming researchers have investigated other forms


of control.  For example, LOGLISP (Robinson and Sibert, 1982) has breadth-


first traversal of the search tree, and IC-Prolog (Clark and McCabe, 1979) has


co-routining.  MU-Prolog (Naish, 1986) allows suspension to provide a correct


implementation of negation and to prevent the computation from searching in-


finite branches in certain cases. Wait declarations are generated (Naish, 1985b)


that are related to the conditions on termination of Prolog programs given in


Section 7.2.



   A methodology for systematically constructing simple Prolog programs is


given in Deville (1990). Essential to Deville's methods are specifications, a s*
 *ubject


touched upon in Section 13.3.



   Analysis of Prolog programs, and logic programs more generally, has become


a hot topic of research. Most analyses are based on some form of abstract inter-




7.6                                                   Background  135



pretation, a topic beyond the scope of this book. The initial work in Prolog can


be found in Mellish (1985), and a view of leading research groups can be found


in a special issue of the Journal of Logic Programming (1993).


   Extensive work has also appeared recently on analyzing termination of Prolog


programs. A starting place for this topic is Plumer (1990).
